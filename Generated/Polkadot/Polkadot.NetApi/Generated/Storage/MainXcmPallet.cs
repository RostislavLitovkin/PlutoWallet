//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Polkadot.NetApi.Generated.Storage
{
    
    
    /// <summary>
    /// >> XcmPalletStorage
    /// </summary>
    public sealed class XcmPalletStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> XcmPalletStorage Constructor
        /// </summary>
        public XcmPalletStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("XcmPallet", "QueryCounter"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U64)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("XcmPallet", "Queries"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U64), typeof(Polkadot.NetApi.Generated.Model.pallet_xcm.pallet.EnumQueryStatus)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("XcmPallet", "AssetTraps"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Identity}, typeof(Polkadot.NetApi.Generated.Model.primitive_types.H256), typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("XcmPallet", "SafeXcmVersion"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("XcmPallet", "SupportedVersion"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation>), typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("XcmPallet", "VersionNotifiers"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation>), typeof(Substrate.NetApi.Model.Types.Primitive.U64)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("XcmPallet", "VersionNotifyTargets"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation>), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U64, Polkadot.NetApi.Generated.Model.sp_weights.weight_v2.Weight, Substrate.NetApi.Model.Types.Primitive.U32>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("XcmPallet", "VersionDiscoveryQueue"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Polkadot.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT36)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("XcmPallet", "CurrentMigration"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Polkadot.NetApi.Generated.Model.pallet_xcm.pallet.EnumVersionMigrationStage)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("XcmPallet", "RemoteLockedFungibles"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedAssetId>), typeof(Polkadot.NetApi.Generated.Model.pallet_xcm.pallet.RemoteLockedFungibleRecord)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("XcmPallet", "LockedFungibles"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Polkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(Polkadot.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT38)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("XcmPallet", "XcmExecutionSuspended"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.Bool)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("XcmPallet", "ShouldRecordXcm"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.Bool)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("XcmPallet", "RecordedXcm"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Polkadot.NetApi.Generated.Model.staging_xcm.v4.XcmT1)));
        }
        
        /// <summary>
        /// >> QueryCounterParams
        ///  The latest available query index.
        /// </summary>
        public static string QueryCounterParams()
        {
            return RequestGenerator.GetStorage("XcmPallet", "QueryCounter", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> QueryCounterDefault
        /// Default value as hex string
        /// </summary>
        public static string QueryCounterDefault()
        {
            return "0x0000000000000000";
        }
        
        /// <summary>
        /// >> QueryCounter
        ///  The latest available query index.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U64> QueryCounter(string blockhash, CancellationToken token)
        {
            string parameters = XcmPalletStorage.QueryCounterParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U64>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> QueriesParams
        ///  The ongoing queries.
        /// </summary>
        public static string QueriesParams(Substrate.NetApi.Model.Types.Primitive.U64 key)
        {
            return RequestGenerator.GetStorage("XcmPallet", "Queries", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> QueriesDefault
        /// Default value as hex string
        /// </summary>
        public static string QueriesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Queries
        ///  The ongoing queries.
        /// </summary>
        public async Task<Polkadot.NetApi.Generated.Model.pallet_xcm.pallet.EnumQueryStatus> Queries(Substrate.NetApi.Model.Types.Primitive.U64 key, string blockhash, CancellationToken token)
        {
            string parameters = XcmPalletStorage.QueriesParams(key);
            var result = await _client.GetStorageAsync<Polkadot.NetApi.Generated.Model.pallet_xcm.pallet.EnumQueryStatus>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> AssetTrapsParams
        ///  The existing asset traps.
        /// 
        ///  Key is the blake2 256 hash of (origin, versioned `Assets`) pair. Value is the number of
        ///  times this pair has been trapped (usually just 1 if it exists at all).
        /// </summary>
        public static string AssetTrapsParams(Polkadot.NetApi.Generated.Model.primitive_types.H256 key)
        {
            return RequestGenerator.GetStorage("XcmPallet", "AssetTraps", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Identity}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> AssetTrapsDefault
        /// Default value as hex string
        /// </summary>
        public static string AssetTrapsDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> AssetTraps
        ///  The existing asset traps.
        /// 
        ///  Key is the blake2 256 hash of (origin, versioned `Assets`) pair. Value is the number of
        ///  times this pair has been trapped (usually just 1 if it exists at all).
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> AssetTraps(Polkadot.NetApi.Generated.Model.primitive_types.H256 key, string blockhash, CancellationToken token)
        {
            string parameters = XcmPalletStorage.AssetTrapsParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> SafeXcmVersionParams
        ///  Default version to encode XCM when latest version of destination is unknown. If `None`,
        ///  then the destinations whose XCM version is unknown are considered unreachable.
        /// </summary>
        public static string SafeXcmVersionParams()
        {
            return RequestGenerator.GetStorage("XcmPallet", "SafeXcmVersion", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> SafeXcmVersionDefault
        /// Default value as hex string
        /// </summary>
        public static string SafeXcmVersionDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> SafeXcmVersion
        ///  Default version to encode XCM when latest version of destination is unknown. If `None`,
        ///  then the destinations whose XCM version is unknown are considered unreachable.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> SafeXcmVersion(string blockhash, CancellationToken token)
        {
            string parameters = XcmPalletStorage.SafeXcmVersionParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> SupportedVersionParams
        ///  The Latest versions that we know various locations support.
        /// </summary>
        public static string SupportedVersionParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation> key)
        {
            return RequestGenerator.GetStorage("XcmPallet", "SupportedVersion", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> SupportedVersionDefault
        /// Default value as hex string
        /// </summary>
        public static string SupportedVersionDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> SupportedVersion
        ///  The Latest versions that we know various locations support.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> SupportedVersion(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation> key, string blockhash, CancellationToken token)
        {
            string parameters = XcmPalletStorage.SupportedVersionParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> VersionNotifiersParams
        ///  All locations that we have requested version notifications from.
        /// </summary>
        public static string VersionNotifiersParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation> key)
        {
            return RequestGenerator.GetStorage("XcmPallet", "VersionNotifiers", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> VersionNotifiersDefault
        /// Default value as hex string
        /// </summary>
        public static string VersionNotifiersDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> VersionNotifiers
        ///  All locations that we have requested version notifications from.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U64> VersionNotifiers(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation> key, string blockhash, CancellationToken token)
        {
            string parameters = XcmPalletStorage.VersionNotifiersParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U64>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> VersionNotifyTargetsParams
        ///  The target locations that are subscribed to our version changes, as well as the most recent
        ///  of our versions we informed them of.
        /// </summary>
        public static string VersionNotifyTargetsParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation> key)
        {
            return RequestGenerator.GetStorage("XcmPallet", "VersionNotifyTargets", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> VersionNotifyTargetsDefault
        /// Default value as hex string
        /// </summary>
        public static string VersionNotifyTargetsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> VersionNotifyTargets
        ///  The target locations that are subscribed to our version changes, as well as the most recent
        ///  of our versions we informed them of.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U64, Polkadot.NetApi.Generated.Model.sp_weights.weight_v2.Weight, Substrate.NetApi.Model.Types.Primitive.U32>> VersionNotifyTargets(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation> key, string blockhash, CancellationToken token)
        {
            string parameters = XcmPalletStorage.VersionNotifyTargetsParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U64, Polkadot.NetApi.Generated.Model.sp_weights.weight_v2.Weight, Substrate.NetApi.Model.Types.Primitive.U32>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> VersionDiscoveryQueueParams
        ///  Destinations whose latest XCM version we would like to know. Duplicates not allowed, and
        ///  the `u32` counter is the number of times that a send to the destination has been attempted,
        ///  which is used as a prioritization.
        /// </summary>
        public static string VersionDiscoveryQueueParams()
        {
            return RequestGenerator.GetStorage("XcmPallet", "VersionDiscoveryQueue", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> VersionDiscoveryQueueDefault
        /// Default value as hex string
        /// </summary>
        public static string VersionDiscoveryQueueDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> VersionDiscoveryQueue
        ///  Destinations whose latest XCM version we would like to know. Duplicates not allowed, and
        ///  the `u32` counter is the number of times that a send to the destination has been attempted,
        ///  which is used as a prioritization.
        /// </summary>
        public async Task<Polkadot.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT36> VersionDiscoveryQueue(string blockhash, CancellationToken token)
        {
            string parameters = XcmPalletStorage.VersionDiscoveryQueueParams();
            var result = await _client.GetStorageAsync<Polkadot.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT36>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CurrentMigrationParams
        ///  The current migration's stage, if any.
        /// </summary>
        public static string CurrentMigrationParams()
        {
            return RequestGenerator.GetStorage("XcmPallet", "CurrentMigration", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CurrentMigrationDefault
        /// Default value as hex string
        /// </summary>
        public static string CurrentMigrationDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> CurrentMigration
        ///  The current migration's stage, if any.
        /// </summary>
        public async Task<Polkadot.NetApi.Generated.Model.pallet_xcm.pallet.EnumVersionMigrationStage> CurrentMigration(string blockhash, CancellationToken token)
        {
            string parameters = XcmPalletStorage.CurrentMigrationParams();
            var result = await _client.GetStorageAsync<Polkadot.NetApi.Generated.Model.pallet_xcm.pallet.EnumVersionMigrationStage>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> RemoteLockedFungiblesParams
        ///  Fungible assets which we know are locked on a remote chain.
        /// </summary>
        public static string RemoteLockedFungiblesParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedAssetId> key)
        {
            return RequestGenerator.GetStorage("XcmPallet", "RemoteLockedFungibles", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> RemoteLockedFungiblesDefault
        /// Default value as hex string
        /// </summary>
        public static string RemoteLockedFungiblesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> RemoteLockedFungibles
        ///  Fungible assets which we know are locked on a remote chain.
        /// </summary>
        public async Task<Polkadot.NetApi.Generated.Model.pallet_xcm.pallet.RemoteLockedFungibleRecord> RemoteLockedFungibles(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedAssetId> key, string blockhash, CancellationToken token)
        {
            string parameters = XcmPalletStorage.RemoteLockedFungiblesParams(key);
            var result = await _client.GetStorageAsync<Polkadot.NetApi.Generated.Model.pallet_xcm.pallet.RemoteLockedFungibleRecord>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> LockedFungiblesParams
        ///  Fungible assets which we know are locked on this chain.
        /// </summary>
        public static string LockedFungiblesParams(Polkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("XcmPallet", "LockedFungibles", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> LockedFungiblesDefault
        /// Default value as hex string
        /// </summary>
        public static string LockedFungiblesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> LockedFungibles
        ///  Fungible assets which we know are locked on this chain.
        /// </summary>
        public async Task<Polkadot.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT38> LockedFungibles(Polkadot.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = XcmPalletStorage.LockedFungiblesParams(key);
            var result = await _client.GetStorageAsync<Polkadot.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT38>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> XcmExecutionSuspendedParams
        ///  Global suspension state of the XCM executor.
        /// </summary>
        public static string XcmExecutionSuspendedParams()
        {
            return RequestGenerator.GetStorage("XcmPallet", "XcmExecutionSuspended", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> XcmExecutionSuspendedDefault
        /// Default value as hex string
        /// </summary>
        public static string XcmExecutionSuspendedDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> XcmExecutionSuspended
        ///  Global suspension state of the XCM executor.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.Bool> XcmExecutionSuspended(string blockhash, CancellationToken token)
        {
            string parameters = XcmPalletStorage.XcmExecutionSuspendedParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.Bool>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ShouldRecordXcmParams
        ///  Whether or not incoming XCMs (both executed locally and received) should be recorded.
        ///  Only one XCM program will be recorded at a time.
        ///  This is meant to be used in runtime APIs, and it's advised it stays false
        ///  for all other use cases, so as to not degrade regular performance.
        /// 
        ///  Only relevant if this pallet is being used as the [`xcm_executor::traits::RecordXcm`]
        ///  implementation in the XCM executor configuration.
        /// </summary>
        public static string ShouldRecordXcmParams()
        {
            return RequestGenerator.GetStorage("XcmPallet", "ShouldRecordXcm", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ShouldRecordXcmDefault
        /// Default value as hex string
        /// </summary>
        public static string ShouldRecordXcmDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ShouldRecordXcm
        ///  Whether or not incoming XCMs (both executed locally and received) should be recorded.
        ///  Only one XCM program will be recorded at a time.
        ///  This is meant to be used in runtime APIs, and it's advised it stays false
        ///  for all other use cases, so as to not degrade regular performance.
        /// 
        ///  Only relevant if this pallet is being used as the [`xcm_executor::traits::RecordXcm`]
        ///  implementation in the XCM executor configuration.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.Bool> ShouldRecordXcm(string blockhash, CancellationToken token)
        {
            string parameters = XcmPalletStorage.ShouldRecordXcmParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.Bool>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> RecordedXcmParams
        ///  If [`ShouldRecordXcm`] is set to true, then the last XCM program executed locally
        ///  will be stored here.
        ///  Runtime APIs can fetch the XCM that was executed by accessing this value.
        /// 
        ///  Only relevant if this pallet is being used as the [`xcm_executor::traits::RecordXcm`]
        ///  implementation in the XCM executor configuration.
        /// </summary>
        public static string RecordedXcmParams()
        {
            return RequestGenerator.GetStorage("XcmPallet", "RecordedXcm", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> RecordedXcmDefault
        /// Default value as hex string
        /// </summary>
        public static string RecordedXcmDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> RecordedXcm
        ///  If [`ShouldRecordXcm`] is set to true, then the last XCM program executed locally
        ///  will be stored here.
        ///  Runtime APIs can fetch the XCM that was executed by accessing this value.
        /// 
        ///  Only relevant if this pallet is being used as the [`xcm_executor::traits::RecordXcm`]
        ///  implementation in the XCM executor configuration.
        /// </summary>
        public async Task<Polkadot.NetApi.Generated.Model.staging_xcm.v4.XcmT1> RecordedXcm(string blockhash, CancellationToken token)
        {
            string parameters = XcmPalletStorage.RecordedXcmParams();
            var result = await _client.GetStorageAsync<Polkadot.NetApi.Generated.Model.staging_xcm.v4.XcmT1>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> XcmPalletCalls
    /// </summary>
    public sealed class XcmPalletCalls
    {
        
        /// <summary>
        /// >> send
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Send(Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation dest, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedXcm message)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(dest.Encode());
            byteArray.AddRange(message.Encode());
            return new Method(99, "XcmPallet", 0, "send", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> teleport_assets
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method TeleportAssets(Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation dest, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation beneficiary, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedAssets assets, Substrate.NetApi.Model.Types.Primitive.U32 fee_asset_item)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(dest.Encode());
            byteArray.AddRange(beneficiary.Encode());
            byteArray.AddRange(assets.Encode());
            byteArray.AddRange(fee_asset_item.Encode());
            return new Method(99, "XcmPallet", 1, "teleport_assets", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> reserve_transfer_assets
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ReserveTransferAssets(Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation dest, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation beneficiary, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedAssets assets, Substrate.NetApi.Model.Types.Primitive.U32 fee_asset_item)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(dest.Encode());
            byteArray.AddRange(beneficiary.Encode());
            byteArray.AddRange(assets.Encode());
            byteArray.AddRange(fee_asset_item.Encode());
            return new Method(99, "XcmPallet", 2, "reserve_transfer_assets", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> execute
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Execute(Polkadot.NetApi.Generated.Model.xcm.EnumVersionedXcm message, Polkadot.NetApi.Generated.Model.sp_weights.weight_v2.Weight max_weight)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(message.Encode());
            byteArray.AddRange(max_weight.Encode());
            return new Method(99, "XcmPallet", 3, "execute", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_xcm_version
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceXcmVersion(Polkadot.NetApi.Generated.Model.staging_xcm.v4.location.Location location, Substrate.NetApi.Model.Types.Primitive.U32 version)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(location.Encode());
            byteArray.AddRange(version.Encode());
            return new Method(99, "XcmPallet", 4, "force_xcm_version", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_default_xcm_version
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceDefaultXcmVersion(Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32> maybe_xcm_version)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(maybe_xcm_version.Encode());
            return new Method(99, "XcmPallet", 5, "force_default_xcm_version", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_subscribe_version_notify
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceSubscribeVersionNotify(Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation location)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(location.Encode());
            return new Method(99, "XcmPallet", 6, "force_subscribe_version_notify", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_unsubscribe_version_notify
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceUnsubscribeVersionNotify(Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation location)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(location.Encode());
            return new Method(99, "XcmPallet", 7, "force_unsubscribe_version_notify", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> limited_reserve_transfer_assets
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method LimitedReserveTransferAssets(Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation dest, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation beneficiary, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedAssets assets, Substrate.NetApi.Model.Types.Primitive.U32 fee_asset_item, Polkadot.NetApi.Generated.Model.xcm.v3.EnumWeightLimit weight_limit)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(dest.Encode());
            byteArray.AddRange(beneficiary.Encode());
            byteArray.AddRange(assets.Encode());
            byteArray.AddRange(fee_asset_item.Encode());
            byteArray.AddRange(weight_limit.Encode());
            return new Method(99, "XcmPallet", 8, "limited_reserve_transfer_assets", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> limited_teleport_assets
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method LimitedTeleportAssets(Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation dest, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation beneficiary, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedAssets assets, Substrate.NetApi.Model.Types.Primitive.U32 fee_asset_item, Polkadot.NetApi.Generated.Model.xcm.v3.EnumWeightLimit weight_limit)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(dest.Encode());
            byteArray.AddRange(beneficiary.Encode());
            byteArray.AddRange(assets.Encode());
            byteArray.AddRange(fee_asset_item.Encode());
            byteArray.AddRange(weight_limit.Encode());
            return new Method(99, "XcmPallet", 9, "limited_teleport_assets", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_suspension
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceSuspension(Substrate.NetApi.Model.Types.Primitive.Bool suspended)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(suspended.Encode());
            return new Method(99, "XcmPallet", 10, "force_suspension", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> transfer_assets
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method TransferAssets(Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation dest, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation beneficiary, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedAssets assets, Substrate.NetApi.Model.Types.Primitive.U32 fee_asset_item, Polkadot.NetApi.Generated.Model.xcm.v3.EnumWeightLimit weight_limit)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(dest.Encode());
            byteArray.AddRange(beneficiary.Encode());
            byteArray.AddRange(assets.Encode());
            byteArray.AddRange(fee_asset_item.Encode());
            byteArray.AddRange(weight_limit.Encode());
            return new Method(99, "XcmPallet", 11, "transfer_assets", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> claim_assets
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ClaimAssets(Polkadot.NetApi.Generated.Model.xcm.EnumVersionedAssets assets, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation beneficiary)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(assets.Encode());
            byteArray.AddRange(beneficiary.Encode());
            return new Method(99, "XcmPallet", 12, "claim_assets", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> transfer_assets_using_type_and_then
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method TransferAssetsUsingTypeAndThen(Polkadot.NetApi.Generated.Model.xcm.EnumVersionedLocation dest, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedAssets assets, Polkadot.NetApi.Generated.Model.staging_xcm_executor.traits.asset_transfer.EnumTransferType assets_transfer_type, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedAssetId remote_fees_id, Polkadot.NetApi.Generated.Model.staging_xcm_executor.traits.asset_transfer.EnumTransferType fees_transfer_type, Polkadot.NetApi.Generated.Model.xcm.EnumVersionedXcm custom_xcm_on_dest, Polkadot.NetApi.Generated.Model.xcm.v3.EnumWeightLimit weight_limit)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(dest.Encode());
            byteArray.AddRange(assets.Encode());
            byteArray.AddRange(assets_transfer_type.Encode());
            byteArray.AddRange(remote_fees_id.Encode());
            byteArray.AddRange(fees_transfer_type.Encode());
            byteArray.AddRange(custom_xcm_on_dest.Encode());
            byteArray.AddRange(weight_limit.Encode());
            return new Method(99, "XcmPallet", 13, "transfer_assets_using_type_and_then", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> XcmPalletConstants
    /// </summary>
    public sealed class XcmPalletConstants
    {
    }
    
    /// <summary>
    /// >> XcmPalletErrors
    /// </summary>
    public enum XcmPalletErrors
    {
        
        /// <summary>
        /// >> Unreachable
        /// The desired destination was unreachable, generally because there is a no way of routing
        /// to it.
        /// </summary>
        Unreachable,
        
        /// <summary>
        /// >> SendFailure
        /// There was some other issue (i.e. not to do with routing) in sending the message.
        /// Perhaps a lack of space for buffering the message.
        /// </summary>
        SendFailure,
        
        /// <summary>
        /// >> Filtered
        /// The message execution fails the filter.
        /// </summary>
        Filtered,
        
        /// <summary>
        /// >> UnweighableMessage
        /// The message's weight could not be determined.
        /// </summary>
        UnweighableMessage,
        
        /// <summary>
        /// >> DestinationNotInvertible
        /// The destination `Location` provided cannot be inverted.
        /// </summary>
        DestinationNotInvertible,
        
        /// <summary>
        /// >> Empty
        /// The assets to be sent are empty.
        /// </summary>
        Empty,
        
        /// <summary>
        /// >> CannotReanchor
        /// Could not re-anchor the assets to declare the fees for the destination chain.
        /// </summary>
        CannotReanchor,
        
        /// <summary>
        /// >> TooManyAssets
        /// Too many assets have been attempted for transfer.
        /// </summary>
        TooManyAssets,
        
        /// <summary>
        /// >> InvalidOrigin
        /// Origin is invalid for sending.
        /// </summary>
        InvalidOrigin,
        
        /// <summary>
        /// >> BadVersion
        /// The version of the `Versioned` value used is not able to be interpreted.
        /// </summary>
        BadVersion,
        
        /// <summary>
        /// >> BadLocation
        /// The given location could not be used (e.g. because it cannot be expressed in the
        /// desired version of XCM).
        /// </summary>
        BadLocation,
        
        /// <summary>
        /// >> NoSubscription
        /// The referenced subscription could not be found.
        /// </summary>
        NoSubscription,
        
        /// <summary>
        /// >> AlreadySubscribed
        /// The location is invalid since it already has a subscription from us.
        /// </summary>
        AlreadySubscribed,
        
        /// <summary>
        /// >> CannotCheckOutTeleport
        /// Could not check-out the assets for teleportation to the destination chain.
        /// </summary>
        CannotCheckOutTeleport,
        
        /// <summary>
        /// >> LowBalance
        /// The owner does not own (all) of the asset that they wish to do the operation on.
        /// </summary>
        LowBalance,
        
        /// <summary>
        /// >> TooManyLocks
        /// The asset owner has too many locks on the asset.
        /// </summary>
        TooManyLocks,
        
        /// <summary>
        /// >> AccountNotSovereign
        /// The given account is not an identifiable sovereign account for any location.
        /// </summary>
        AccountNotSovereign,
        
        /// <summary>
        /// >> FeesNotMet
        /// The operation required fees to be paid which the initiator could not meet.
        /// </summary>
        FeesNotMet,
        
        /// <summary>
        /// >> LockNotFound
        /// A remote lock with the corresponding data could not be found.
        /// </summary>
        LockNotFound,
        
        /// <summary>
        /// >> InUse
        /// The unlock operation cannot succeed because there are still consumers of the lock.
        /// </summary>
        InUse,
        
        /// <summary>
        /// >> InvalidAssetUnknownReserve
        /// Invalid asset, reserve chain could not be determined for it.
        /// </summary>
        InvalidAssetUnknownReserve,
        
        /// <summary>
        /// >> InvalidAssetUnsupportedReserve
        /// Invalid asset, do not support remote asset reserves with different fees reserves.
        /// </summary>
        InvalidAssetUnsupportedReserve,
        
        /// <summary>
        /// >> TooManyReserves
        /// Too many assets with different reserve locations have been attempted for transfer.
        /// </summary>
        TooManyReserves,
        
        /// <summary>
        /// >> LocalExecutionIncomplete
        /// Local XCM execution incomplete.
        /// </summary>
        LocalExecutionIncomplete,
    }
}
