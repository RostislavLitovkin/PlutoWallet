//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace Hydration.NetApi.Generated.Model.pallet_lbp.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> create_pool
        /// Create a new liquidity bootstrapping pool for given asset pair.
        /// 
        /// For any asset pair, only one pool can exist at a time.
        /// 
        /// The dispatch origin for this call must be `T::CreatePoolOrigin`.
        /// The pool is created with initial liquidity provided by the `pool_owner` who must have
        /// sufficient funds free.
        /// 
        /// The pool starts uninitialized and update_pool call should be called once created to set the start block.
        /// 
        /// This function should be dispatched from governing entity `T::CreatePoolOrigin`
        /// 
        /// Parameters:
        /// - `pool_owner`: the future owner of the new pool.
        /// - `asset_a`: { asset_id, amount } Asset ID and initial liquidity amount.
        /// - `asset_b`: { asset_id, amount } Asset ID and initial liquidity amount.
        /// - `initial_weight`: Initial weight of the asset_a. 1_000_000 corresponding to 1% and 100_000_000 to 100%
        /// this should be higher than final weight
        /// - `final_weight`: Final weight of the asset_a. 1_000_000 corresponding to 1% and 100_000_000 to 100%
        /// this should be lower than initial weight
        /// - `weight_curve`: The weight function used to update the LBP weights. Currently,
        /// there is only one weight function implemented, the linear function.
        /// - `fee`: The trading fee charged on every trade distributed to `fee_collector`.
        /// - `fee_collector`: The account to which trading fees will be transferred.
        /// - `repay_target`: The amount of tokens to repay to separate fee_collector account. Until this amount is
        /// reached, fee will be increased to 20% and taken from the pool
        /// 
        /// Emits `PoolCreated` event when successful.
        /// 
        /// BEWARE: We are taking the fee from the accumulated asset. If the accumulated asset is sold to the pool,
        /// the fee cost is transferred to the pool. If its bought from the pool the buyer bears the cost.
        /// This increases the price of the sold asset on every trade. Make sure to only run this with
        /// previously illiquid assets.
        /// </summary>
        create_pool = 0,
        
        /// <summary>
        /// >> update_pool_data
        /// Update pool data of a pool.
        /// 
        /// The dispatch origin for this call must be signed by the pool owner.
        /// 
        /// The pool can be updated only if the sale has not already started.
        /// 
        /// At least one of the following optional parameters has to be specified.
        /// 
        /// Parameters:
        /// - `pool_id`: The identifier of the pool to be updated.
        /// - `start`: The new starting time of the sale. This parameter is optional.
        /// - `end`: The new ending time of the sale. This parameter is optional.
        /// - `initial_weight`: The new initial weight. This parameter is optional.
        /// - `final_weight`: The new final weight. This parameter is optional.
        /// - `fee`: The new trading fee charged on every trade. This parameter is optional.
        /// - `fee_collector`: The new receiver of trading fees. This parameter is optional.
        /// 
        /// Emits `PoolUpdated` event when successful.
        /// </summary>
        update_pool_data = 1,
        
        /// <summary>
        /// >> add_liquidity
        /// Add liquidity to a pool.
        /// 
        /// Assets to add has to match the pool assets. At least one amount has to be non-zero.
        /// 
        /// The dispatch origin for this call must be signed by the pool owner.
        /// 
        /// Parameters:
        /// - `pool_id`: The identifier of the pool
        /// - `amount_a`: The identifier of the asset and the amount to add.
        /// - `amount_b`: The identifier of the second asset and the amount to add.
        /// 
        /// Emits `LiquidityAdded` event when successful.
        /// </summary>
        add_liquidity = 2,
        
        /// <summary>
        /// >> remove_liquidity
        /// Transfer all the liquidity from a pool back to the pool owner and destroy the pool.
        /// The pool data are also removed from the storage.
        /// 
        /// The pool can't be destroyed during the sale.
        /// 
        /// The dispatch origin for this call must be signed by the pool owner.
        /// 
        /// Parameters:
        /// - `amount_a`: The identifier of the asset and the amount to add.
        /// 
        /// Emits 'LiquidityRemoved' when successful.
        /// </summary>
        remove_liquidity = 3,
        
        /// <summary>
        /// >> sell
        /// Trade `asset_in` for `asset_out`.
        /// 
        /// Executes a swap of `asset_in` for `asset_out`. Price is determined by the pool and is
        /// affected by the amount and proportion of the pool assets and the weights.
        /// 
        /// Trading `fee` is distributed to the `fee_collector`.
        /// 
        /// Parameters:
        /// - `asset_in`: The identifier of the asset being transferred from the account to the pool.
        /// - `asset_out`: The identifier of the asset being transferred from the pool to the account.
        /// - `amount`: The amount of `asset_in`
        /// - `max_limit`: minimum amount of `asset_out` / amount of asset_out to be obtained from the pool in exchange for `asset_in`.
        /// 
        /// Emits `SellExecuted` when successful.
        /// </summary>
        sell = 4,
        
        /// <summary>
        /// >> buy
        /// Trade `asset_in` for `asset_out`.
        /// 
        /// Executes a swap of `asset_in` for `asset_out`. Price is determined by the pool and is
        /// affected by the amount and the proportion of the pool assets and the weights.
        /// 
        /// Trading `fee` is distributed to the `fee_collector`.
        /// 
        /// Parameters:
        /// - `asset_in`: The identifier of the asset being transferred from the account to the pool.
        /// - `asset_out`: The identifier of the asset being transferred from the pool to the account.
        /// - `amount`: The amount of `asset_out`.
        /// - `max_limit`: maximum amount of `asset_in` to be sold in exchange for `asset_out`.
        /// 
        /// Emits `BuyExecuted` when successful.
        /// </summary>
        buy = 5,
    }
    
    /// <summary>
    /// >> 379 - Variant[pallet_lbp.pallet.Call]
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public sealed class EnumCall : BaseEnumRust<Call>
    {
        
        /// <summary>
        /// Initializes a new instance of the class.
        /// </summary>
        public EnumCall()
        {
				AddTypeDecoder<BaseTuple<Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32, Hydration.NetApi.Generated.Model.pallet_lbp.EnumWeightCurveType, Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>, Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.create_pool);
				AddTypeDecoder<BaseTuple<Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Base.BaseOpt<Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>, Substrate.NetApi.Model.Types.Base.BaseOpt<Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>>>(Call.update_pool_data);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U128>>>(Call.add_liquidity);
				AddTypeDecoder<Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32>(Call.remove_liquidity);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.sell);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.buy);
        }
    }
}
