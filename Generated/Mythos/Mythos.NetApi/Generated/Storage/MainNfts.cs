//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Mythos.NetApi.Generated.Storage
{
    
    
    /// <summary>
    /// >> NftsStorage
    /// </summary>
    public sealed class NftsStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> NftsStorage Constructor
        /// </summary>
        public NftsStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "Collection"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256), typeof(Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionDetails)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "BurnedItems"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>), typeof(Substrate.NetApi.Model.Types.Primitive.Bool)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "OwnershipAcceptance"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Mythos.NetApi.Generated.Model.account.AccountId20), typeof(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "Account"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.account.AccountId20, Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "CollectionAccount"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.account.AccountId20, Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256>), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "CollectionRoleOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Mythos.NetApi.Generated.Model.account.AccountId20>), typeof(Mythos.NetApi.Generated.Model.pallet_nfts.types.BitFlagsT3)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "Item"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>), typeof(Mythos.NetApi.Generated.Model.pallet_nfts.types.ItemDetails)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "CollectionMetadataOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256), typeof(Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionMetadata)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "ItemMetadataOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>), typeof(Mythos.NetApi.Generated.Model.pallet_nfts.types.ItemMetadata)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "Attribute"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Mythos.NetApi.Generated.Model.pallet_nfts.types.EnumAttributeNamespace, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT2>), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT1, Mythos.NetApi.Generated.Model.pallet_nfts.types.AttributeDeposit>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "ItemPriceOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.account.AccountId20>>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "ItemAttributesApprovalsOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>), typeof(Mythos.NetApi.Generated.Model.bounded_collections.bounded_btree_set.BoundedBTreeSetT1)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "NextCollectionId"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "PendingSwapOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>), typeof(Mythos.NetApi.Generated.Model.pallet_nfts.types.PendingSwap)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "CollectionConfigOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256), typeof(Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionConfig)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Nfts", "ItemConfigOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>), typeof(Mythos.NetApi.Generated.Model.pallet_nfts.types.ItemConfig)));
        }
        
        /// <summary>
        /// >> CollectionParams
        ///  Details of a collection.
        /// </summary>
        public static string CollectionParams(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 key)
        {
            return RequestGenerator.GetStorage("Nfts", "Collection", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> CollectionDefault
        /// Default value as hex string
        /// </summary>
        public static string CollectionDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Collection
        ///  Details of a collection.
        /// </summary>
        public async Task<Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionDetails> Collection(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.CollectionParams(key);
            var result = await _client.GetStorageAsync<Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionDetails>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> BurnedItemsParams
        ///  Burned items in a collection.
        /// </summary>
        public static string BurnedItemsParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key)
        {
            return RequestGenerator.GetStorage("Nfts", "BurnedItems", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> BurnedItemsDefault
        /// Default value as hex string
        /// </summary>
        public static string BurnedItemsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> BurnedItems
        ///  Burned items in a collection.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.Bool> BurnedItems(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.BurnedItemsParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.Bool>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> OwnershipAcceptanceParams
        ///  The collection, if any, of which an account is willing to take ownership.
        /// </summary>
        public static string OwnershipAcceptanceParams(Mythos.NetApi.Generated.Model.account.AccountId20 key)
        {
            return RequestGenerator.GetStorage("Nfts", "OwnershipAcceptance", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> OwnershipAcceptanceDefault
        /// Default value as hex string
        /// </summary>
        public static string OwnershipAcceptanceDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> OwnershipAcceptance
        ///  The collection, if any, of which an account is willing to take ownership.
        /// </summary>
        public async Task<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256> OwnershipAcceptance(Mythos.NetApi.Generated.Model.account.AccountId20 key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.OwnershipAcceptanceParams(key);
            var result = await _client.GetStorageAsync<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> AccountParams
        ///  The items held by any given account; set out this way so that items owned by a single
        ///  account can be enumerated.
        /// </summary>
        public static string AccountParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.account.AccountId20, Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key)
        {
            return RequestGenerator.GetStorage("Nfts", "Account", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> AccountDefault
        /// Default value as hex string
        /// </summary>
        public static string AccountDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Account
        ///  The items held by any given account; set out this way so that items owned by a single
        ///  account can be enumerated.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple> Account(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.account.AccountId20, Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.AccountParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CollectionAccountParams
        ///  The collections owned by any given account; set out this way so that collections owned by
        ///  a single account can be enumerated.
        /// </summary>
        public static string CollectionAccountParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.account.AccountId20, Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256> key)
        {
            return RequestGenerator.GetStorage("Nfts", "CollectionAccount", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> CollectionAccountDefault
        /// Default value as hex string
        /// </summary>
        public static string CollectionAccountDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> CollectionAccount
        ///  The collections owned by any given account; set out this way so that collections owned by
        ///  a single account can be enumerated.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple> CollectionAccount(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.account.AccountId20, Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256> key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.CollectionAccountParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CollectionRoleOfParams
        ///  The items in existence and their ownership details.
        ///  Stores collection roles as per account.
        /// </summary>
        public static string CollectionRoleOfParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Mythos.NetApi.Generated.Model.account.AccountId20> key)
        {
            return RequestGenerator.GetStorage("Nfts", "CollectionRoleOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> CollectionRoleOfDefault
        /// Default value as hex string
        /// </summary>
        public static string CollectionRoleOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> CollectionRoleOf
        ///  The items in existence and their ownership details.
        ///  Stores collection roles as per account.
        /// </summary>
        public async Task<Mythos.NetApi.Generated.Model.pallet_nfts.types.BitFlagsT3> CollectionRoleOf(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Mythos.NetApi.Generated.Model.account.AccountId20> key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.CollectionRoleOfParams(key);
            var result = await _client.GetStorageAsync<Mythos.NetApi.Generated.Model.pallet_nfts.types.BitFlagsT3>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ItemParams
        ///  The items in existence and their ownership details.
        /// </summary>
        public static string ItemParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key)
        {
            return RequestGenerator.GetStorage("Nfts", "Item", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ItemDefault
        /// Default value as hex string
        /// </summary>
        public static string ItemDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Item
        ///  The items in existence and their ownership details.
        /// </summary>
        public async Task<Mythos.NetApi.Generated.Model.pallet_nfts.types.ItemDetails> Item(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.ItemParams(key);
            var result = await _client.GetStorageAsync<Mythos.NetApi.Generated.Model.pallet_nfts.types.ItemDetails>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CollectionMetadataOfParams
        ///  Metadata of a collection.
        /// </summary>
        public static string CollectionMetadataOfParams(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 key)
        {
            return RequestGenerator.GetStorage("Nfts", "CollectionMetadataOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> CollectionMetadataOfDefault
        /// Default value as hex string
        /// </summary>
        public static string CollectionMetadataOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> CollectionMetadataOf
        ///  Metadata of a collection.
        /// </summary>
        public async Task<Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionMetadata> CollectionMetadataOf(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.CollectionMetadataOfParams(key);
            var result = await _client.GetStorageAsync<Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionMetadata>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ItemMetadataOfParams
        ///  Metadata of an item.
        /// </summary>
        public static string ItemMetadataOfParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key)
        {
            return RequestGenerator.GetStorage("Nfts", "ItemMetadataOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ItemMetadataOfDefault
        /// Default value as hex string
        /// </summary>
        public static string ItemMetadataOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ItemMetadataOf
        ///  Metadata of an item.
        /// </summary>
        public async Task<Mythos.NetApi.Generated.Model.pallet_nfts.types.ItemMetadata> ItemMetadataOf(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.ItemMetadataOfParams(key);
            var result = await _client.GetStorageAsync<Mythos.NetApi.Generated.Model.pallet_nfts.types.ItemMetadata>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> AttributeParams
        ///  Attributes of a collection.
        /// </summary>
        public static string AttributeParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Mythos.NetApi.Generated.Model.pallet_nfts.types.EnumAttributeNamespace, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT2> key)
        {
            return RequestGenerator.GetStorage("Nfts", "Attribute", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> AttributeDefault
        /// Default value as hex string
        /// </summary>
        public static string AttributeDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Attribute
        ///  Attributes of a collection.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT1, Mythos.NetApi.Generated.Model.pallet_nfts.types.AttributeDeposit>> Attribute(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Mythos.NetApi.Generated.Model.pallet_nfts.types.EnumAttributeNamespace, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT2> key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.AttributeParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT1, Mythos.NetApi.Generated.Model.pallet_nfts.types.AttributeDeposit>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ItemPriceOfParams
        ///  A price of an item.
        /// </summary>
        public static string ItemPriceOfParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key)
        {
            return RequestGenerator.GetStorage("Nfts", "ItemPriceOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ItemPriceOfDefault
        /// Default value as hex string
        /// </summary>
        public static string ItemPriceOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ItemPriceOf
        ///  A price of an item.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.account.AccountId20>>> ItemPriceOf(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.ItemPriceOfParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.account.AccountId20>>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ItemAttributesApprovalsOfParams
        ///  Item attribute approvals.
        /// </summary>
        public static string ItemAttributesApprovalsOfParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key)
        {
            return RequestGenerator.GetStorage("Nfts", "ItemAttributesApprovalsOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ItemAttributesApprovalsOfDefault
        /// Default value as hex string
        /// </summary>
        public static string ItemAttributesApprovalsOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ItemAttributesApprovalsOf
        ///  Item attribute approvals.
        /// </summary>
        public async Task<Mythos.NetApi.Generated.Model.bounded_collections.bounded_btree_set.BoundedBTreeSetT1> ItemAttributesApprovalsOf(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.ItemAttributesApprovalsOfParams(key);
            var result = await _client.GetStorageAsync<Mythos.NetApi.Generated.Model.bounded_collections.bounded_btree_set.BoundedBTreeSetT1>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> NextCollectionIdParams
        ///  Stores the `CollectionId` that is going to be used for the next collection.
        ///  This gets incremented whenever a new collection is created.
        /// </summary>
        public static string NextCollectionIdParams()
        {
            return RequestGenerator.GetStorage("Nfts", "NextCollectionId", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> NextCollectionIdDefault
        /// Default value as hex string
        /// </summary>
        public static string NextCollectionIdDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> NextCollectionId
        ///  Stores the `CollectionId` that is going to be used for the next collection.
        ///  This gets incremented whenever a new collection is created.
        /// </summary>
        public async Task<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256> NextCollectionId(string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.NextCollectionIdParams();
            var result = await _client.GetStorageAsync<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> PendingSwapOfParams
        ///  Handles all the pending swaps.
        /// </summary>
        public static string PendingSwapOfParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key)
        {
            return RequestGenerator.GetStorage("Nfts", "PendingSwapOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> PendingSwapOfDefault
        /// Default value as hex string
        /// </summary>
        public static string PendingSwapOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> PendingSwapOf
        ///  Handles all the pending swaps.
        /// </summary>
        public async Task<Mythos.NetApi.Generated.Model.pallet_nfts.types.PendingSwap> PendingSwapOf(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.PendingSwapOfParams(key);
            var result = await _client.GetStorageAsync<Mythos.NetApi.Generated.Model.pallet_nfts.types.PendingSwap>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CollectionConfigOfParams
        ///  Config of a collection.
        /// </summary>
        public static string CollectionConfigOfParams(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 key)
        {
            return RequestGenerator.GetStorage("Nfts", "CollectionConfigOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> CollectionConfigOfDefault
        /// Default value as hex string
        /// </summary>
        public static string CollectionConfigOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> CollectionConfigOf
        ///  Config of a collection.
        /// </summary>
        public async Task<Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionConfig> CollectionConfigOf(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.CollectionConfigOfParams(key);
            var result = await _client.GetStorageAsync<Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionConfig>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ItemConfigOfParams
        ///  Config of an item.
        /// </summary>
        public static string ItemConfigOfParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key)
        {
            return RequestGenerator.GetStorage("Nfts", "ItemConfigOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ItemConfigOfDefault
        /// Default value as hex string
        /// </summary>
        public static string ItemConfigOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ItemConfigOf
        ///  Config of an item.
        /// </summary>
        public async Task<Mythos.NetApi.Generated.Model.pallet_nfts.types.ItemConfig> ItemConfigOf(Substrate.NetApi.Model.Types.Base.BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128> key, string blockhash, CancellationToken token)
        {
            string parameters = NftsStorage.ItemConfigOfParams(key);
            var result = await _client.GetStorageAsync<Mythos.NetApi.Generated.Model.pallet_nfts.types.ItemConfig>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> NftsCalls
    /// </summary>
    public sealed class NftsCalls
    {
        
        /// <summary>
        /// >> create
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Create(Mythos.NetApi.Generated.Model.account.AccountId20 admin, Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionConfig config)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(admin.Encode());
            byteArray.AddRange(config.Encode());
            return new Method(12, "Nfts", 0, "create", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_create
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceCreate(Mythos.NetApi.Generated.Model.account.AccountId20 owner, Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionConfig config)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(owner.Encode());
            byteArray.AddRange(config.Encode());
            return new Method(12, "Nfts", 1, "force_create", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> destroy
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Destroy(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Mythos.NetApi.Generated.Model.pallet_nfts.types.DestroyWitness witness)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(witness.Encode());
            return new Method(12, "Nfts", 2, "destroy", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> mint
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Mint(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> maybe_item, Mythos.NetApi.Generated.Model.account.AccountId20 mint_to, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.pallet_nfts.types.MintWitness> witness_data)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(maybe_item.Encode());
            byteArray.AddRange(mint_to.Encode());
            byteArray.AddRange(witness_data.Encode());
            return new Method(12, "Nfts", 3, "mint", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_mint
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceMint(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> maybe_item, Mythos.NetApi.Generated.Model.account.AccountId20 mint_to, Mythos.NetApi.Generated.Model.pallet_nfts.types.ItemConfig item_config)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(maybe_item.Encode());
            byteArray.AddRange(mint_to.Encode());
            byteArray.AddRange(item_config.Encode());
            return new Method(12, "Nfts", 4, "force_mint", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> burn
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Burn(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 item)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(item.Encode());
            return new Method(12, "Nfts", 5, "burn", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> transfer
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Transfer(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 item, Mythos.NetApi.Generated.Model.account.AccountId20 dest)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(item.Encode());
            byteArray.AddRange(dest.Encode());
            return new Method(12, "Nfts", 6, "transfer", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> redeposit
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Redeposit(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U128> items)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(items.Encode());
            return new Method(12, "Nfts", 7, "redeposit", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> lock_item_transfer
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method LockItemTransfer(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 item)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(item.Encode());
            return new Method(12, "Nfts", 8, "lock_item_transfer", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> unlock_item_transfer
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method UnlockItemTransfer(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 item)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(item.Encode());
            return new Method(12, "Nfts", 9, "unlock_item_transfer", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> lock_collection
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method LockCollection(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Mythos.NetApi.Generated.Model.pallet_nfts.types.BitFlagsT1 lock_settings)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(lock_settings.Encode());
            return new Method(12, "Nfts", 10, "lock_collection", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> transfer_ownership
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method TransferOwnership(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Mythos.NetApi.Generated.Model.account.AccountId20 new_owner)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(new_owner.Encode());
            return new Method(12, "Nfts", 11, "transfer_ownership", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_team
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetTeam(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.account.AccountId20> issuer, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.account.AccountId20> admin, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.account.AccountId20> freezer)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(issuer.Encode());
            byteArray.AddRange(admin.Encode());
            byteArray.AddRange(freezer.Encode());
            return new Method(12, "Nfts", 12, "set_team", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_collection_owner
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceCollectionOwner(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Mythos.NetApi.Generated.Model.account.AccountId20 owner)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(owner.Encode());
            return new Method(12, "Nfts", 13, "force_collection_owner", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_collection_config
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceCollectionConfig(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionConfig config)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(config.Encode());
            return new Method(12, "Nfts", 14, "force_collection_config", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> approve_transfer
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ApproveTransfer(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 item, Mythos.NetApi.Generated.Model.account.AccountId20 @delegate, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32> maybe_deadline)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(item.Encode());
            byteArray.AddRange(@delegate.Encode());
            byteArray.AddRange(maybe_deadline.Encode());
            return new Method(12, "Nfts", 15, "approve_transfer", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> cancel_approval
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method CancelApproval(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 item, Mythos.NetApi.Generated.Model.account.AccountId20 @delegate)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(item.Encode());
            byteArray.AddRange(@delegate.Encode());
            return new Method(12, "Nfts", 16, "cancel_approval", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> clear_all_transfer_approvals
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ClearAllTransferApprovals(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 item)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(item.Encode());
            return new Method(12, "Nfts", 17, "clear_all_transfer_approvals", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> lock_item_properties
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method LockItemProperties(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 item, Substrate.NetApi.Model.Types.Primitive.Bool lock_metadata, Substrate.NetApi.Model.Types.Primitive.Bool lock_attributes)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(item.Encode());
            byteArray.AddRange(lock_metadata.Encode());
            byteArray.AddRange(lock_attributes.Encode());
            return new Method(12, "Nfts", 18, "lock_item_properties", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_attribute
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetAttribute(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> maybe_item, Mythos.NetApi.Generated.Model.pallet_nfts.types.EnumAttributeNamespace @namespace, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT2 key, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT1 value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(maybe_item.Encode());
            byteArray.AddRange(@namespace.Encode());
            byteArray.AddRange(key.Encode());
            byteArray.AddRange(value.Encode());
            return new Method(12, "Nfts", 19, "set_attribute", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_set_attribute
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceSetAttribute(Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.account.AccountId20> set_as, Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> maybe_item, Mythos.NetApi.Generated.Model.pallet_nfts.types.EnumAttributeNamespace @namespace, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT2 key, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT1 value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(set_as.Encode());
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(maybe_item.Encode());
            byteArray.AddRange(@namespace.Encode());
            byteArray.AddRange(key.Encode());
            byteArray.AddRange(value.Encode());
            return new Method(12, "Nfts", 20, "force_set_attribute", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> clear_attribute
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ClearAttribute(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> maybe_item, Mythos.NetApi.Generated.Model.pallet_nfts.types.EnumAttributeNamespace @namespace, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT2 key)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(maybe_item.Encode());
            byteArray.AddRange(@namespace.Encode());
            byteArray.AddRange(key.Encode());
            return new Method(12, "Nfts", 21, "clear_attribute", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> approve_item_attributes
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ApproveItemAttributes(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 item, Mythos.NetApi.Generated.Model.account.AccountId20 @delegate)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(item.Encode());
            byteArray.AddRange(@delegate.Encode());
            return new Method(12, "Nfts", 22, "approve_item_attributes", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> cancel_item_attributes_approval
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method CancelItemAttributesApproval(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 item, Mythos.NetApi.Generated.Model.account.AccountId20 @delegate, Mythos.NetApi.Generated.Model.pallet_nfts.types.CancelAttributesApprovalWitness witness)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(item.Encode());
            byteArray.AddRange(@delegate.Encode());
            byteArray.AddRange(witness.Encode());
            return new Method(12, "Nfts", 23, "cancel_item_attributes_approval", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_metadata
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetMetadata(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 item, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT1 data)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(item.Encode());
            byteArray.AddRange(data.Encode());
            return new Method(12, "Nfts", 24, "set_metadata", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> clear_metadata
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ClearMetadata(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 item)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(item.Encode());
            return new Method(12, "Nfts", 25, "clear_metadata", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_collection_metadata
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetCollectionMetadata(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT1 data)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(data.Encode());
            return new Method(12, "Nfts", 26, "set_collection_metadata", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> clear_collection_metadata
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ClearCollectionMetadata(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            return new Method(12, "Nfts", 27, "clear_collection_metadata", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_accept_ownership
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetAcceptOwnership(Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256> maybe_collection)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(maybe_collection.Encode());
            return new Method(12, "Nfts", 28, "set_accept_ownership", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_collection_max_supply
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetCollectionMaxSupply(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 max_supply)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(max_supply.Encode());
            return new Method(12, "Nfts", 29, "set_collection_max_supply", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> update_mint_settings
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method UpdateMintSettings(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Mythos.NetApi.Generated.Model.pallet_nfts.types.MintSettings mint_settings)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(mint_settings.Encode());
            return new Method(12, "Nfts", 30, "update_mint_settings", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_price
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetPrice(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 item, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> price, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.account.AccountId20> whitelisted_buyer)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(item.Encode());
            byteArray.AddRange(price.Encode());
            byteArray.AddRange(whitelisted_buyer.Encode());
            return new Method(12, "Nfts", 31, "set_price", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> buy_item
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method BuyItem(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 collection, Substrate.NetApi.Model.Types.Primitive.U128 item, Substrate.NetApi.Model.Types.Primitive.U128 bid_price)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection.Encode());
            byteArray.AddRange(item.Encode());
            byteArray.AddRange(bid_price.Encode());
            return new Method(12, "Nfts", 32, "buy_item", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> pay_tips
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method PayTips(Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6 tips)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(tips.Encode());
            return new Method(12, "Nfts", 33, "pay_tips", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> create_swap
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method CreateSwap(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 offered_collection, Substrate.NetApi.Model.Types.Primitive.U128 offered_item, Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 desired_collection, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> maybe_desired_item, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.pallet_nfts.types.PriceWithDirection> maybe_price, Substrate.NetApi.Model.Types.Primitive.U32 duration)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(offered_collection.Encode());
            byteArray.AddRange(offered_item.Encode());
            byteArray.AddRange(desired_collection.Encode());
            byteArray.AddRange(maybe_desired_item.Encode());
            byteArray.AddRange(maybe_price.Encode());
            byteArray.AddRange(duration.Encode());
            return new Method(12, "Nfts", 34, "create_swap", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> cancel_swap
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method CancelSwap(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 offered_collection, Substrate.NetApi.Model.Types.Primitive.U128 offered_item)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(offered_collection.Encode());
            byteArray.AddRange(offered_item.Encode());
            return new Method(12, "Nfts", 35, "cancel_swap", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> claim_swap
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ClaimSwap(Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 send_collection, Substrate.NetApi.Model.Types.Primitive.U128 send_item, Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256 receive_collection, Substrate.NetApi.Model.Types.Primitive.U128 receive_item, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.pallet_nfts.types.PriceWithDirection> witness_price)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(send_collection.Encode());
            byteArray.AddRange(send_item.Encode());
            byteArray.AddRange(receive_collection.Encode());
            byteArray.AddRange(receive_item.Encode());
            byteArray.AddRange(witness_price.Encode());
            return new Method(12, "Nfts", 36, "claim_swap", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> mint_pre_signed
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method MintPreSigned(Mythos.NetApi.Generated.Model.pallet_nfts.types.PreSignedMint mint_data, Mythos.NetApi.Generated.Model.account.EthereumSignature signature, Mythos.NetApi.Generated.Model.account.AccountId20 signer)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(mint_data.Encode());
            byteArray.AddRange(signature.Encode());
            byteArray.AddRange(signer.Encode());
            return new Method(12, "Nfts", 37, "mint_pre_signed", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_attributes_pre_signed
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetAttributesPreSigned(Mythos.NetApi.Generated.Model.pallet_nfts.types.PreSignedAttributes data, Mythos.NetApi.Generated.Model.account.EthereumSignature signature, Mythos.NetApi.Generated.Model.account.AccountId20 signer)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(data.Encode());
            byteArray.AddRange(signature.Encode());
            byteArray.AddRange(signer.Encode());
            return new Method(12, "Nfts", 38, "set_attributes_pre_signed", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> NftsConstants
    /// </summary>
    public sealed class NftsConstants
    {
        
        /// <summary>
        /// >> CollectionDeposit
        ///  The basic amount of funds that must be reserved for collection.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 CollectionDeposit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x00000000000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> ItemDeposit
        ///  The basic amount of funds that must be reserved for an item.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 ItemDeposit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x00000000000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> MetadataDepositBase
        ///  The basic amount of funds that must be reserved when adding metadata to your item.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 MetadataDepositBase()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x00000000000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> AttributeDepositBase
        ///  The basic amount of funds that must be reserved when adding an attribute to an item.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 AttributeDepositBase()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x00000000000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> DepositPerByte
        ///  The additional funds that must be reserved for the number of bytes store in metadata,
        ///  either "normal" metadata or attribute metadata.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 DepositPerByte()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x00000000000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> StringLimit
        ///  The maximum length of data stored on-chain.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 StringLimit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x00010000");
            return result;
        }
        
        /// <summary>
        /// >> KeyLimit
        ///  The maximum length of an attribute key.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 KeyLimit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x40000000");
            return result;
        }
        
        /// <summary>
        /// >> ValueLimit
        ///  The maximum length of an attribute value.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 ValueLimit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x00010000");
            return result;
        }
        
        /// <summary>
        /// >> ApprovalsLimit
        ///  The maximum approvals an item could have.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 ApprovalsLimit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x14000000");
            return result;
        }
        
        /// <summary>
        /// >> ItemAttributesApprovalsLimit
        ///  The maximum attributes approvals an item could have.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 ItemAttributesApprovalsLimit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x1E000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxTips
        ///  The max number of tips a user could send.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxTips()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x0A000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxDeadlineDuration
        ///  The max duration in blocks for deadlines.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxDeadlineDuration()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x001A4F00");
            return result;
        }
        
        /// <summary>
        /// >> MaxAttributesPerCall
        ///  The max number of attributes a user could set per call.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxAttributesPerCall()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x0A000000");
            return result;
        }
        
        /// <summary>
        /// >> Features
        ///  Disables some of pallet's features.
        /// </summary>
        public Mythos.NetApi.Generated.Model.pallet_nfts.types.BitFlagsT4 Features()
        {
            var result = new Mythos.NetApi.Generated.Model.pallet_nfts.types.BitFlagsT4();
            result.Create("0x0000000000000000");
            return result;
        }
    }
    
    /// <summary>
    /// >> NftsErrors
    /// </summary>
    public enum NftsErrors
    {
        
        /// <summary>
        /// >> NoPermission
        /// The signing account has no permission to do the operation.
        /// </summary>
        NoPermission,
        
        /// <summary>
        /// >> UnknownCollection
        /// The given item ID is unknown.
        /// </summary>
        UnknownCollection,
        
        /// <summary>
        /// >> AlreadyExists
        /// The item ID has already been used for an item.
        /// </summary>
        AlreadyExists,
        
        /// <summary>
        /// >> ApprovalExpired
        /// The approval had a deadline that expired, so the approval isn't valid anymore.
        /// </summary>
        ApprovalExpired,
        
        /// <summary>
        /// >> WrongOwner
        /// The owner turned out to be different to what was expected.
        /// </summary>
        WrongOwner,
        
        /// <summary>
        /// >> BadWitness
        /// The witness data given does not match the current state of the chain.
        /// </summary>
        BadWitness,
        
        /// <summary>
        /// >> CollectionIdInUse
        /// Collection ID is already taken.
        /// </summary>
        CollectionIdInUse,
        
        /// <summary>
        /// >> ItemsNonTransferable
        /// Items within that collection are non-transferable.
        /// </summary>
        ItemsNonTransferable,
        
        /// <summary>
        /// >> NotDelegate
        /// The provided account is not a delegate.
        /// </summary>
        NotDelegate,
        
        /// <summary>
        /// >> WrongDelegate
        /// The delegate turned out to be different to what was expected.
        /// </summary>
        WrongDelegate,
        
        /// <summary>
        /// >> Unapproved
        /// No approval exists that would allow the transfer.
        /// </summary>
        Unapproved,
        
        /// <summary>
        /// >> Unaccepted
        /// The named owner has not signed ownership acceptance of the collection.
        /// </summary>
        Unaccepted,
        
        /// <summary>
        /// >> ItemLocked
        /// The item is locked (non-transferable).
        /// </summary>
        ItemLocked,
        
        /// <summary>
        /// >> LockedItemAttributes
        /// Item's attributes are locked.
        /// </summary>
        LockedItemAttributes,
        
        /// <summary>
        /// >> LockedCollectionAttributes
        /// Collection's attributes are locked.
        /// </summary>
        LockedCollectionAttributes,
        
        /// <summary>
        /// >> LockedItemMetadata
        /// Item's metadata is locked.
        /// </summary>
        LockedItemMetadata,
        
        /// <summary>
        /// >> LockedCollectionMetadata
        /// Collection's metadata is locked.
        /// </summary>
        LockedCollectionMetadata,
        
        /// <summary>
        /// >> MaxSupplyReached
        /// All items have been minted.
        /// </summary>
        MaxSupplyReached,
        
        /// <summary>
        /// >> MaxSupplyLocked
        /// The max supply is locked and can't be changed.
        /// </summary>
        MaxSupplyLocked,
        
        /// <summary>
        /// >> MaxSupplyTooSmall
        /// The provided max supply is less than the number of items a collection already has.
        /// </summary>
        MaxSupplyTooSmall,
        
        /// <summary>
        /// >> UnknownItem
        /// The given item ID is unknown.
        /// </summary>
        UnknownItem,
        
        /// <summary>
        /// >> UnknownSwap
        /// Swap doesn't exist.
        /// </summary>
        UnknownSwap,
        
        /// <summary>
        /// >> MetadataNotFound
        /// The given item has no metadata set.
        /// </summary>
        MetadataNotFound,
        
        /// <summary>
        /// >> AttributeNotFound
        /// The provided attribute can't be found.
        /// </summary>
        AttributeNotFound,
        
        /// <summary>
        /// >> NotForSale
        /// Item is not for sale.
        /// </summary>
        NotForSale,
        
        /// <summary>
        /// >> BidTooLow
        /// The provided bid is too low.
        /// </summary>
        BidTooLow,
        
        /// <summary>
        /// >> ReachedApprovalLimit
        /// The item has reached its approval limit.
        /// </summary>
        ReachedApprovalLimit,
        
        /// <summary>
        /// >> DeadlineExpired
        /// The deadline has already expired.
        /// </summary>
        DeadlineExpired,
        
        /// <summary>
        /// >> WrongDuration
        /// The duration provided should be less than or equal to `MaxDeadlineDuration`.
        /// </summary>
        WrongDuration,
        
        /// <summary>
        /// >> MethodDisabled
        /// The method is disabled by system settings.
        /// </summary>
        MethodDisabled,
        
        /// <summary>
        /// >> WrongSetting
        /// The provided setting can't be set.
        /// </summary>
        WrongSetting,
        
        /// <summary>
        /// >> InconsistentItemConfig
        /// Item's config already exists and should be equal to the provided one.
        /// </summary>
        InconsistentItemConfig,
        
        /// <summary>
        /// >> NoConfig
        /// Config for a collection or an item can't be found.
        /// </summary>
        NoConfig,
        
        /// <summary>
        /// >> RolesNotCleared
        /// Some roles were not cleared.
        /// </summary>
        RolesNotCleared,
        
        /// <summary>
        /// >> MintNotStarted
        /// Mint has not started yet.
        /// </summary>
        MintNotStarted,
        
        /// <summary>
        /// >> MintEnded
        /// Mint has already ended.
        /// </summary>
        MintEnded,
        
        /// <summary>
        /// >> AlreadyClaimed
        /// The provided Item was already used for claiming.
        /// </summary>
        AlreadyClaimed,
        
        /// <summary>
        /// >> IncorrectData
        /// The provided data is incorrect.
        /// </summary>
        IncorrectData,
        
        /// <summary>
        /// >> WrongOrigin
        /// The extrinsic was sent by the wrong origin.
        /// </summary>
        WrongOrigin,
        
        /// <summary>
        /// >> WrongSignature
        /// The provided signature is incorrect.
        /// </summary>
        WrongSignature,
        
        /// <summary>
        /// >> IncorrectMetadata
        /// The provided metadata might be too long.
        /// </summary>
        IncorrectMetadata,
        
        /// <summary>
        /// >> MaxAttributesLimitReached
        /// Can't set more attributes per one call.
        /// </summary>
        MaxAttributesLimitReached,
        
        /// <summary>
        /// >> WrongNamespace
        /// The provided namespace isn't supported in this call.
        /// </summary>
        WrongNamespace,
        
        /// <summary>
        /// >> CollectionNotEmpty
        /// Can't delete non-empty collections.
        /// </summary>
        CollectionNotEmpty,
        
        /// <summary>
        /// >> WitnessRequired
        /// The witness data should be provided.
        /// </summary>
        WitnessRequired,
        
        /// <summary>
        /// >> MaxSupplyRequired
        /// It is required to specify the collection's maximum supply.
        /// </summary>
        MaxSupplyRequired,
        
        /// <summary>
        /// >> InvalidItemId
        /// ItemId must be under the collection's maximum supply.
        /// </summary>
        InvalidItemId,
        
        /// <summary>
        /// >> ItemIdNotSerial
        /// When serial minting is enabled items must be consecutive.
        /// </summary>
        ItemIdNotSerial,
        
        /// <summary>
        /// >> SerialMintEnabled
        /// The collection must be configured for serial minting.
        /// </summary>
        SerialMintEnabled,
        
        /// <summary>
        /// >> AlreadyBurned
        /// The item as already burned.
        /// </summary>
        AlreadyBurned,
    }
}
