//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace Mythos.NetApi.Generated.Model.pallet_nfts.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> create
        /// Issue a new collection of non-fungible items from a public origin.
        /// 
        /// This new collection has no items initially and its owner is the origin.
        /// 
        /// The origin must be Signed and the sender must have sufficient funds free.
        /// 
        /// `CollectionDeposit` funds of sender are reserved.
        /// 
        /// Parameters:
        /// - `admin`: The admin of this collection. The admin is the initial address of each
        /// member of the collection's admin team.
        /// 
        /// Emits `Created` event when successful.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        create = 0,
        
        /// <summary>
        /// >> force_create
        /// Issue a new collection of non-fungible items from a privileged origin.
        /// 
        /// This new collection has no items initially.
        /// 
        /// The origin must conform to `ForceOrigin`.
        /// 
        /// Unlike `create`, no funds are reserved.
        /// 
        /// - `owner`: The owner of this collection of items. The owner has full superuser
        ///   permissions over this item, but may later change and configure the permissions using
        ///   `transfer_ownership` and `set_team`.
        /// 
        /// Emits `ForceCreated` event when successful.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        force_create = 1,
        
        /// <summary>
        /// >> destroy
        /// Destroy a collection of fungible items.
        /// 
        /// The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the
        /// owner of the `collection`.
        /// 
        /// NOTE: The collection must have 0 items to be destroyed.
        /// 
        /// - `collection`: The identifier of the collection to be destroyed.
        /// - `witness`: Information on the items minted in the collection. This must be
        /// correct.
        /// 
        /// Emits `Destroyed` event when successful.
        /// 
        /// Weight: `O(m + c + a)` where:
        /// - `m = witness.item_metadatas`
        /// - `c = witness.item_configs`
        /// - `a = witness.attributes`
        /// </summary>
        destroy = 2,
        
        /// <summary>
        /// >> mint
        /// Mint an item of a particular collection.
        /// 
        /// The origin must be Signed and the sender must comply with the `mint_settings` rules.
        /// 
        /// - `collection`: The collection of the item to be minted.
        /// - `maybe_item`: An identifier of the new item. If the collection mints serially, this should be `None`.
        /// - `mint_to`: Account into which the item will be minted.
        /// - `witness_data`: When the mint type is `HolderOf(collection_id)`, then the owned
        ///   item_id from that collection needs to be provided within the witness data object. If
        ///   the mint price is set, then it should be additionally confirmed in the `witness_data`.
        /// 
        /// Note: the deposit will be taken from the `origin` and not the `owner` of the `item`.
        /// 
        /// Emits `Issued` event when successful.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        mint = 3,
        
        /// <summary>
        /// >> force_mint
        /// Mint an item of a particular collection from a privileged origin.
        /// 
        /// The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the
        /// Issuer of the `collection`.
        /// 
        /// - `collection`: The collection of the item to be minted.
        /// - `maybe_item`: An identifier of the new item.
        /// - `mint_to`: Account into which the item will be minted.
        /// - `item_config`: A config of the new item.
        /// 
        /// Emits `Issued` event when successful.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        force_mint = 4,
        
        /// <summary>
        /// >> burn
        /// Destroy a single item.
        /// 
        /// The origin must conform to `ForceOrigin` or must be Signed and the signing account must
        /// be the owner of the `item`.
        /// 
        /// - `collection`: The collection of the item to be burned.
        /// - `item`: The item to be burned.
        /// 
        /// Emits `Burned`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        burn = 5,
        
        /// <summary>
        /// >> transfer
        /// Move an item from the sender account to another.
        /// 
        /// Origin must be Signed and the signing account must be either:
        /// - the Owner of the `item`;
        /// - the approved delegate for the `item` (in this case, the approval is reset).
        /// 
        /// Arguments:
        /// - `collection`: The collection of the item to be transferred.
        /// - `item`: The item to be transferred.
        /// - `dest`: The account to receive ownership of the item.
        /// 
        /// Emits `Transferred`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        transfer = 6,
        
        /// <summary>
        /// >> redeposit
        /// Re-evaluate the deposits on some items.
        /// 
        /// Origin must be Signed and the sender should be the Owner of the `collection`.
        /// 
        /// - `collection`: The collection of the items to be reevaluated.
        /// - `items`: The items of the collection whose deposits will be reevaluated.
        /// 
        /// NOTE: This exists as a best-effort function. Any items which are unknown or
        /// in the case that the owner account does not have reservable funds to pay for a
        /// deposit increase are ignored. Generally the owner isn't going to call this on items
        /// whose existing deposit is less than the refreshed deposit as it would only cost them,
        /// so it's of little consequence.
        /// 
        /// It will still return an error in the case that the collection is unknown or the signer
        /// is not permitted to call it.
        /// 
        /// Weight: `O(items.len())`
        /// </summary>
        redeposit = 7,
        
        /// <summary>
        /// >> lock_item_transfer
        /// Disallow further unprivileged transfer of an item.
        /// 
        /// Origin must be Signed and the sender should be the Freezer of the `collection`.
        /// 
        /// - `collection`: The collection of the item to be changed.
        /// - `item`: The item to become non-transferable.
        /// 
        /// Emits `ItemTransferLocked`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        lock_item_transfer = 8,
        
        /// <summary>
        /// >> unlock_item_transfer
        /// Re-allow unprivileged transfer of an item.
        /// 
        /// Origin must be Signed and the sender should be the Freezer of the `collection`.
        /// 
        /// - `collection`: The collection of the item to be changed.
        /// - `item`: The item to become transferable.
        /// 
        /// Emits `ItemTransferUnlocked`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        unlock_item_transfer = 9,
        
        /// <summary>
        /// >> lock_collection
        /// Disallows specified settings for the whole collection.
        /// 
        /// Origin must be Signed and the sender should be the Owner of the `collection`.
        /// 
        /// - `collection`: The collection to be locked.
        /// - `lock_settings`: The settings to be locked.
        /// 
        /// Note: it's possible to only lock(set) the setting, but not to unset it.
        /// 
        /// Emits `CollectionLocked`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        lock_collection = 10,
        
        /// <summary>
        /// >> transfer_ownership
        /// Change the Owner of a collection.
        /// 
        /// Origin must be Signed and the sender should be the Owner of the `collection`.
        /// 
        /// - `collection`: The collection whose owner should be changed.
        /// - `owner`: The new Owner of this collection. They must have called
        ///   `set_accept_ownership` with `collection` in order for this operation to succeed.
        /// 
        /// Emits `OwnerChanged`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        transfer_ownership = 11,
        
        /// <summary>
        /// >> set_team
        /// Change the Issuer, Admin and Freezer of a collection.
        /// 
        /// Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
        /// `collection`.
        /// 
        /// Note: by setting the role to `None` only the `ForceOrigin` will be able to change it
        /// after to `Some(account)`.
        /// 
        /// - `collection`: The collection whose team should be changed.
        /// - `issuer`: The new Issuer of this collection.
        /// - `admin`: The new Admin of this collection.
        /// - `freezer`: The new Freezer of this collection.
        /// 
        /// Emits `TeamChanged`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        set_team = 12,
        
        /// <summary>
        /// >> force_collection_owner
        /// Change the Owner of a collection.
        /// 
        /// Origin must be `ForceOrigin`.
        /// 
        /// - `collection`: The identifier of the collection.
        /// - `owner`: The new Owner of this collection.
        /// 
        /// Emits `OwnerChanged`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        force_collection_owner = 13,
        
        /// <summary>
        /// >> force_collection_config
        /// Change the config of a collection.
        /// 
        /// Origin must be `ForceOrigin`.
        /// 
        /// - `collection`: The identifier of the collection.
        /// - `config`: The new config of this collection.
        /// 
        /// Emits `CollectionConfigChanged`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        force_collection_config = 14,
        
        /// <summary>
        /// >> approve_transfer
        /// Approve an item to be transferred by a delegated third-party account.
        /// 
        /// Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
        /// `item`.
        /// 
        /// - `collection`: The collection of the item to be approved for delegated transfer.
        /// - `item`: The item to be approved for delegated transfer.
        /// - `delegate`: The account to delegate permission to transfer the item.
        /// - `maybe_deadline`: Optional deadline for the approval. Specified by providing the
        /// 	number of blocks after which the approval will expire
        /// 
        /// Emits `TransferApproved` on success.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        approve_transfer = 15,
        
        /// <summary>
        /// >> cancel_approval
        /// Cancel one of the transfer approvals for a specific item.
        /// 
        /// Origin must be either:
        /// - the `Force` origin;
        /// - `Signed` with the signer being the Owner of the `item`;
        /// 
        /// Arguments:
        /// - `collection`: The collection of the item of whose approval will be cancelled.
        /// - `item`: The item of the collection of whose approval will be cancelled.
        /// - `delegate`: The account that is going to loose their approval.
        /// 
        /// Emits `ApprovalCancelled` on success.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        cancel_approval = 16,
        
        /// <summary>
        /// >> clear_all_transfer_approvals
        /// Cancel all the approvals of a specific item.
        /// 
        /// Origin must be either:
        /// - the `Force` origin;
        /// - `Signed` with the signer being the Owner of the `item`;
        /// 
        /// Arguments:
        /// - `collection`: The collection of the item of whose approvals will be cleared.
        /// - `item`: The item of the collection of whose approvals will be cleared.
        /// 
        /// Emits `AllApprovalsCancelled` on success.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        clear_all_transfer_approvals = 17,
        
        /// <summary>
        /// >> lock_item_properties
        /// Disallows changing the metadata or attributes of the item.
        /// 
        /// Origin must be either `ForceOrigin` or Signed and the sender should be the Admin
        /// of the `collection`.
        /// 
        /// - `collection`: The collection if the `item`.
        /// - `item`: An item to be locked.
        /// - `lock_metadata`: Specifies whether the metadata should be locked.
        /// - `lock_attributes`: Specifies whether the attributes in the `CollectionOwner` namespace
        ///   should be locked.
        /// 
        /// Note: `lock_attributes` affects the attributes in the `CollectionOwner` namespace only.
        /// When the metadata or attributes are locked, it won't be possible the unlock them.
        /// 
        /// Emits `ItemPropertiesLocked`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        lock_item_properties = 18,
        
        /// <summary>
        /// >> set_attribute
        /// Set an attribute for a collection or item.
        /// 
        /// Origin must be Signed and must conform to the namespace ruleset:
        /// - `CollectionOwner` namespace could be modified by the `collection` Admin only;
        /// - `ItemOwner` namespace could be modified by the `maybe_item` owner only. `maybe_item`
        ///   should be set in that case;
        /// - `Account(AccountId)` namespace could be modified only when the `origin` was given a
        ///   permission to do so;
        /// 
        /// The funds of `origin` are reserved according to the formula:
        /// `AttributeDepositBase + DepositPerByte * (key.len + value.len)` taking into
        /// account any already reserved funds.
        /// 
        /// - `collection`: The identifier of the collection whose item's metadata to set.
        /// - `maybe_item`: The identifier of the item whose metadata to set.
        /// - `namespace`: Attribute's namespace.
        /// - `key`: The key of the attribute.
        /// - `value`: The value to which to set the attribute.
        /// 
        /// Emits `AttributeSet`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        set_attribute = 19,
        
        /// <summary>
        /// >> force_set_attribute
        /// Force-set an attribute for a collection or item.
        /// 
        /// Origin must be `ForceOrigin`.
        /// 
        /// If the attribute already exists and it was set by another account, the deposit
        /// will be returned to the previous owner.
        /// 
        /// - `set_as`: An optional owner of the attribute.
        /// - `collection`: The identifier of the collection whose item's metadata to set.
        /// - `maybe_item`: The identifier of the item whose metadata to set.
        /// - `namespace`: Attribute's namespace.
        /// - `key`: The key of the attribute.
        /// - `value`: The value to which to set the attribute.
        /// 
        /// Emits `AttributeSet`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        force_set_attribute = 20,
        
        /// <summary>
        /// >> clear_attribute
        /// Clear an attribute for a collection or item.
        /// 
        /// Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
        /// attribute.
        /// 
        /// Any deposit is freed for the collection's owner.
        /// 
        /// - `collection`: The identifier of the collection whose item's metadata to clear.
        /// - `maybe_item`: The identifier of the item whose metadata to clear.
        /// - `namespace`: Attribute's namespace.
        /// - `key`: The key of the attribute.
        /// 
        /// Emits `AttributeCleared`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        clear_attribute = 21,
        
        /// <summary>
        /// >> approve_item_attributes
        /// Approve item's attributes to be changed by a delegated third-party account.
        /// 
        /// Origin must be Signed and must be an owner of the `item`.
        /// 
        /// - `collection`: A collection of the item.
        /// - `item`: The item that holds attributes.
        /// - `delegate`: The account to delegate permission to change attributes of the item.
        /// 
        /// Emits `ItemAttributesApprovalAdded` on success.
        /// </summary>
        approve_item_attributes = 22,
        
        /// <summary>
        /// >> cancel_item_attributes_approval
        /// Cancel the previously provided approval to change item's attributes.
        /// All the previously set attributes by the `delegate` will be removed.
        /// 
        /// Origin must be Signed and must be an owner of the `item`.
        /// 
        /// - `collection`: Collection that the item is contained within.
        /// - `item`: The item that holds attributes.
        /// - `delegate`: The previously approved account to remove.
        /// 
        /// Emits `ItemAttributesApprovalRemoved` on success.
        /// </summary>
        cancel_item_attributes_approval = 23,
        
        /// <summary>
        /// >> set_metadata
        /// Set the metadata for an item.
        /// 
        /// Origin must be either `ForceOrigin` or Signed and the sender should be the Admin of the
        /// `collection`.
        /// 
        /// If the origin is Signed, then funds of signer are reserved according to the formula:
        /// `MetadataDepositBase + DepositPerByte * data.len` taking into
        /// account any already reserved funds.
        /// 
        /// - `collection`: The identifier of the collection whose item's metadata to set.
        /// - `item`: The identifier of the item whose metadata to set.
        /// - `data`: The general information of this item. Limited in length by `StringLimit`.
        /// 
        /// Emits `ItemMetadataSet`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        set_metadata = 24,
        
        /// <summary>
        /// >> clear_metadata
        /// Clear the metadata for an item.
        /// 
        /// Origin must be either `ForceOrigin` or Signed and the sender should be the Admin of the
        /// `collection`.
        /// 
        /// Any deposit is freed for the collection's owner.
        /// 
        /// - `collection`: The identifier of the collection whose item's metadata to clear.
        /// - `item`: The identifier of the item whose metadata to clear.
        /// 
        /// Emits `ItemMetadataCleared`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        clear_metadata = 25,
        
        /// <summary>
        /// >> set_collection_metadata
        /// Set the metadata for a collection.
        /// 
        /// Origin must be either `ForceOrigin` or `Signed` and the sender should be the Admin of
        /// the `collection`.
        /// 
        /// If the origin is `Signed`, then funds of signer are reserved according to the formula:
        /// `MetadataDepositBase + DepositPerByte * data.len` taking into
        /// account any already reserved funds.
        /// 
        /// - `collection`: The identifier of the item whose metadata to update.
        /// - `data`: The general information of this item. Limited in length by `StringLimit`.
        /// 
        /// Emits `CollectionMetadataSet`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        set_collection_metadata = 26,
        
        /// <summary>
        /// >> clear_collection_metadata
        /// Clear the metadata for a collection.
        /// 
        /// Origin must be either `ForceOrigin` or `Signed` and the sender should be the Admin of
        /// the `collection`.
        /// 
        /// Any deposit is freed for the collection's owner.
        /// 
        /// - `collection`: The identifier of the collection whose metadata to clear.
        /// 
        /// Emits `CollectionMetadataCleared`.
        /// 
        /// Weight: `O(1)`
        /// </summary>
        clear_collection_metadata = 27,
        
        /// <summary>
        /// >> set_accept_ownership
        /// Set (or reset) the acceptance of ownership for a particular account.
        /// 
        /// Origin must be `Signed` and if `maybe_collection` is `Some`, then the signer must have a
        /// provider reference.
        /// 
        /// - `maybe_collection`: The identifier of the collection whose ownership the signer is
        ///   willing to accept, or if `None`, an indication that the signer is willing to accept no
        ///   ownership transferal.
        /// 
        /// Emits `OwnershipAcceptanceChanged`.
        /// </summary>
        set_accept_ownership = 28,
        
        /// <summary>
        /// >> set_collection_max_supply
        /// Set the maximum number of items a collection could have.
        /// 
        /// Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
        /// the `collection`.
        /// 
        /// - `collection`: The identifier of the collection to change.
        /// - `max_supply`: The maximum number of items a collection could have.
        /// 
        /// Emits `CollectionMaxSupplySet` event when successful.
        /// </summary>
        set_collection_max_supply = 29,
        
        /// <summary>
        /// >> update_mint_settings
        /// Update mint settings.
        /// 
        /// Origin must be either `ForceOrigin` or `Signed` and the sender should be the Issuer
        /// of the `collection`.
        /// 
        /// - `collection`: The identifier of the collection to change.
        /// - `mint_settings`: The new mint settings.
        /// 
        /// Emits `CollectionMintSettingsUpdated` event when successful.
        /// </summary>
        update_mint_settings = 30,
        
        /// <summary>
        /// >> set_price
        /// Set (or reset) the price for an item.
        /// 
        /// Origin must be Signed and must be the owner of the `item`.
        /// 
        /// - `collection`: The collection of the item.
        /// - `item`: The item to set the price for.
        /// - `price`: The price for the item. Pass `None`, to reset the price.
        /// - `buyer`: Restricts the buy operation to a specific account.
        /// 
        /// Emits `ItemPriceSet` on success if the price is not `None`.
        /// Emits `ItemPriceRemoved` on success if the price is `None`.
        /// </summary>
        set_price = 31,
        
        /// <summary>
        /// >> buy_item
        /// Allows to buy an item if it's up for sale.
        /// 
        /// Origin must be Signed and must not be the owner of the `item`.
        /// 
        /// - `collection`: The collection of the item.
        /// - `item`: The item the sender wants to buy.
        /// - `bid_price`: The price the sender is willing to pay.
        /// 
        /// Emits `ItemBought` on success.
        /// </summary>
        buy_item = 32,
        
        /// <summary>
        /// >> pay_tips
        /// Allows to pay the tips.
        /// 
        /// Origin must be Signed.
        /// 
        /// - `tips`: Tips array.
        /// 
        /// Emits `TipSent` on every tip transfer.
        /// </summary>
        pay_tips = 33,
        
        /// <summary>
        /// >> create_swap
        /// Register a new atomic swap, declaring an intention to send an `item` in exchange for
        /// `desired_item` from origin to target on the current blockchain.
        /// The target can execute the swap during the specified `duration` of blocks (if set).
        /// Additionally, the price could be set for the desired `item`.
        /// 
        /// Origin must be Signed and must be an owner of the `item`.
        /// 
        /// - `collection`: The collection of the item.
        /// - `item`: The item an owner wants to give.
        /// - `desired_collection`: The collection of the desired item.
        /// - `desired_item`: The desired item an owner wants to receive.
        /// - `maybe_price`: The price an owner is willing to pay or receive for the desired `item`.
        /// - `duration`: A deadline for the swap. Specified by providing the number of blocks
        /// 	after which the swap will expire.
        /// 
        /// Emits `SwapCreated` on success.
        /// </summary>
        create_swap = 34,
        
        /// <summary>
        /// >> cancel_swap
        /// Cancel an atomic swap.
        /// 
        /// Origin must be Signed.
        /// Origin must be an owner of the `item` if the deadline hasn't expired.
        /// 
        /// - `collection`: The collection of the item.
        /// - `item`: The item an owner wants to give.
        /// 
        /// Emits `SwapCancelled` on success.
        /// </summary>
        cancel_swap = 35,
        
        /// <summary>
        /// >> claim_swap
        /// Claim an atomic swap.
        /// This method executes a pending swap, that was created by a counterpart before.
        /// 
        /// Origin must be Signed and must be an owner of the `item`.
        /// 
        /// - `send_collection`: The collection of the item to be sent.
        /// - `send_item`: The item to be sent.
        /// - `receive_collection`: The collection of the item to be received.
        /// - `receive_item`: The item to be received.
        /// - `witness_price`: A price that was previously agreed on.
        /// 
        /// Emits `SwapClaimed` on success.
        /// </summary>
        claim_swap = 36,
        
        /// <summary>
        /// >> mint_pre_signed
        /// Mint an item by providing the pre-signed approval.
        /// 
        /// Origin must be Signed.
        /// 
        /// - `mint_data`: The pre-signed approval that consists of the information about the item,
        ///   its metadata, attributes, who can mint it (`None` for anyone) and until what block
        ///   number.
        /// - `signature`: The signature of the `data` object.
        /// - `signer`: The `data` object's signer. Should be an Issuer of the collection.
        /// 
        /// Emits `Issued` on success.
        /// Emits `AttributeSet` if the attributes were provided.
        /// Emits `ItemMetadataSet` if the metadata was not empty.
        /// </summary>
        mint_pre_signed = 37,
        
        /// <summary>
        /// >> set_attributes_pre_signed
        /// Set attributes for an item by providing the pre-signed approval.
        /// 
        /// Origin must be Signed and must be an owner of the `data.item`.
        /// 
        /// - `data`: The pre-signed approval that consists of the information about the item,
        ///   attributes to update and until what block number.
        /// - `signature`: The signature of the `data` object.
        /// - `signer`: The `data` object's signer. Should be an Admin of the collection for the
        ///   `CollectionOwner` namespace.
        /// 
        /// Emits `AttributeSet` for each provided attribute.
        /// Emits `ItemAttributesApprovalAdded` if the approval wasn't set before.
        /// Emits `PreSignedAttributesSet` on success.
        /// </summary>
        set_attributes_pre_signed = 38,
    }
    
    /// <summary>
    /// >> 226 - Variant[pallet_nfts.pallet.Call]
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public sealed class EnumCall : BaseEnumRust<Call>
    {
        
        /// <summary>
        /// Initializes a new instance of the class.
        /// </summary>
        public EnumCall()
        {
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.account.AccountId20, Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionConfig>>(Call.create);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.account.AccountId20, Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionConfig>>(Call.force_create);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Mythos.NetApi.Generated.Model.pallet_nfts.types.DestroyWitness>>(Call.destroy);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Mythos.NetApi.Generated.Model.account.AccountId20, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.pallet_nfts.types.MintWitness>>>(Call.mint);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Mythos.NetApi.Generated.Model.account.AccountId20, Mythos.NetApi.Generated.Model.pallet_nfts.types.ItemConfig>>(Call.force_mint);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.burn);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128, Mythos.NetApi.Generated.Model.account.AccountId20>>(Call.transfer);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U128>>>(Call.redeposit);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.lock_item_transfer);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.unlock_item_transfer);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Mythos.NetApi.Generated.Model.pallet_nfts.types.BitFlagsT1>>(Call.lock_collection);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Mythos.NetApi.Generated.Model.account.AccountId20>>(Call.transfer_ownership);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.account.AccountId20>, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.account.AccountId20>, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.account.AccountId20>>>(Call.set_team);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Mythos.NetApi.Generated.Model.account.AccountId20>>(Call.force_collection_owner);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Mythos.NetApi.Generated.Model.pallet_nfts.types.CollectionConfig>>(Call.force_collection_config);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128, Mythos.NetApi.Generated.Model.account.AccountId20, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32>>>(Call.approve_transfer);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128, Mythos.NetApi.Generated.Model.account.AccountId20>>(Call.cancel_approval);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.clear_all_transfer_approvals);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.Bool, Substrate.NetApi.Model.Types.Primitive.Bool>>(Call.lock_item_properties);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Mythos.NetApi.Generated.Model.pallet_nfts.types.EnumAttributeNamespace, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT2, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT1>>(Call.set_attribute);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.account.AccountId20>, Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Mythos.NetApi.Generated.Model.pallet_nfts.types.EnumAttributeNamespace, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT2, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT1>>(Call.force_set_attribute);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Mythos.NetApi.Generated.Model.pallet_nfts.types.EnumAttributeNamespace, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT2>>(Call.clear_attribute);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128, Mythos.NetApi.Generated.Model.account.AccountId20>>(Call.approve_item_attributes);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128, Mythos.NetApi.Generated.Model.account.AccountId20, Mythos.NetApi.Generated.Model.pallet_nfts.types.CancelAttributesApprovalWitness>>(Call.cancel_item_attributes_approval);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT1>>(Call.set_metadata);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.clear_metadata);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT1>>(Call.set_collection_metadata);
				AddTypeDecoder<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256>(Call.clear_collection_metadata);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256>>(Call.set_accept_ownership);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.set_collection_max_supply);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Mythos.NetApi.Generated.Model.pallet_nfts.types.MintSettings>>(Call.update_mint_settings);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.account.AccountId20>>>(Call.set_price);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.buy_item);
				AddTypeDecoder<Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT6>(Call.pay_tips);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128, Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.pallet_nfts.types.PriceWithDirection>, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.create_swap);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.cancel_swap);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128, Mythos.NetApi.Generated.Model.runtime_common.IncrementableU256, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Base.BaseOpt<Mythos.NetApi.Generated.Model.pallet_nfts.types.PriceWithDirection>>>(Call.claim_swap);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.pallet_nfts.types.PreSignedMint, Mythos.NetApi.Generated.Model.account.EthereumSignature, Mythos.NetApi.Generated.Model.account.AccountId20>>(Call.mint_pre_signed);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Model.pallet_nfts.types.PreSignedAttributes, Mythos.NetApi.Generated.Model.account.EthereumSignature, Mythos.NetApi.Generated.Model.account.AccountId20>>(Call.set_attributes_pre_signed);
        }
    }
}
