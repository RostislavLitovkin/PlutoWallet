//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace Mythos.NetApi.Generated.Model.pallet_multibatching.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> batch
        /// Execute multiple calls from multiple callers in a single batch.
        /// 
        /// If one of the calls fails, the whole batch reverts.
        /// 
        /// This utility is primarily intended to support cases where the calls
        /// are interdependent - think a trade operation where Alice intends
        /// to transfer an nft item X to Bob if and only if Bob sends an nft
        /// item Y to Alice. For that reason it is designed in such a way
        /// that every caller must sign the batch as a whole instead of only
        /// their own calls. This has a pleasant side effect of reducing the
        /// execution cost compared to signing each call separately, as only
        /// one signature is required per each unique caller.
        /// 
        /// As the data signed by callers is a well-formed call, this allows
        /// users to validate what they're signing by just decoding the data
        /// using a third-party tool before signing them, e.g. by just going
        /// to the decode tab on the official Parachain Explorer
        /// <https://polkadot.js.org/apps/#/extrinsics/decode>.
        /// 
        /// # Arguments
        /// 
        /// - `domain` - the domain of this operation that must be unique per
        /// pallet instance across networks.
        /// - `sender` - must be the same as the sender of the transaction
        /// - `bias` - an arbitrary 32 byte array that can be used to avoid
        /// hash collisions.
        /// - `calls` - a sequence of calls to execute on behalf of their
        /// respective callers.
        /// - `approvals` - a set of signatures, one signature per a unique
        /// caller.
        /// 
        /// # Usage
        /// 
        /// - Prepare a complete `batch()` call with empty vec for `approvals`
        /// parameter.
        /// - Encode the call into scale-encoded bytes.
        /// - Form the `approvals` array by having every caller that has
        /// calls in the batch sign these bytes, one signature per caller.
        /// - Send the `batch()` call with the same data and the collected
        /// approvals.
        /// 
        /// </summary>
        batch = 0,
        
        /// <summary>
        /// >> batch_v2
        /// Execute multiple calls from multiple callers in a single batch.
        /// 
        /// If one of the calls fails, the whole batch reverts.
        /// 
        /// This function works the same as [Pallet::batch], but the bytes signed by
        /// approvers must be wrapped in between <Bytes> ... </Bytes>.
        /// This is how the rawSign is currently implemented in modern substrate clients.
        /// 
        /// </summary>
        batch_v2 = 1,
    }
    
    /// <summary>
    /// >> 250 - Variant[pallet_multibatching.pallet.Call]
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public sealed class EnumCall : BaseEnumRust<Call>
    {
        
        /// <summary>
        /// Initializes a new instance of the class.
        /// </summary>
        public EnumCall()
        {
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Types.Base.Arr8U8, Mythos.NetApi.Generated.Model.account.AccountId20, Mythos.NetApi.Generated.Types.Base.Arr32U8, Substrate.NetApi.Model.Types.Primitive.U64, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT7, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT8>>(Call.batch);
				AddTypeDecoder<BaseTuple<Mythos.NetApi.Generated.Types.Base.Arr8U8, Mythos.NetApi.Generated.Model.account.AccountId20, Mythos.NetApi.Generated.Types.Base.Arr32U8, Substrate.NetApi.Model.Types.Primitive.U64, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT7, Mythos.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT8>>(Call.batch_v2);
        }
    }
}
