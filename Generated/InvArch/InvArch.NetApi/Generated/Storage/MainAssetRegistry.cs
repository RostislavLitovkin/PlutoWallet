//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace InvArch.NetApi.Generated.Storage
{
    
    
    /// <summary>
    /// >> AssetRegistryStorage
    /// </summary>
    public sealed class AssetRegistryStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> AssetRegistryStorage Constructor
        /// </summary>
        public AssetRegistryStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("AssetRegistry", "Metadata"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(InvArch.NetApi.Generated.Model.orml_traits.asset_registry.AssetMetadata)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("AssetRegistry", "LocationToAssetId"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(InvArch.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation), typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("AssetRegistry", "LastAssetId"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
        }
        
        /// <summary>
        /// >> MetadataParams
        ///  The metadata of an asset, indexed by asset id.
        /// </summary>
        public static string MetadataParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("AssetRegistry", "Metadata", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> MetadataDefault
        /// Default value as hex string
        /// </summary>
        public static string MetadataDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Metadata
        ///  The metadata of an asset, indexed by asset id.
        /// </summary>
        public async Task<InvArch.NetApi.Generated.Model.orml_traits.asset_registry.AssetMetadata> Metadata(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = AssetRegistryStorage.MetadataParams(key);
            var result = await _client.GetStorageAsync<InvArch.NetApi.Generated.Model.orml_traits.asset_registry.AssetMetadata>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> LocationToAssetIdParams
        ///  Maps a location to an asset id - useful when processing xcm
        ///  messages.
        /// </summary>
        public static string LocationToAssetIdParams(InvArch.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation key)
        {
            return RequestGenerator.GetStorage("AssetRegistry", "LocationToAssetId", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> LocationToAssetIdDefault
        /// Default value as hex string
        /// </summary>
        public static string LocationToAssetIdDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> LocationToAssetId
        ///  Maps a location to an asset id - useful when processing xcm
        ///  messages.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> LocationToAssetId(InvArch.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation key, string blockhash, CancellationToken token)
        {
            string parameters = AssetRegistryStorage.LocationToAssetIdParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> LastAssetIdParams
        ///  The last processed asset id - used when assigning a sequential id.
        /// </summary>
        public static string LastAssetIdParams()
        {
            return RequestGenerator.GetStorage("AssetRegistry", "LastAssetId", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> LastAssetIdDefault
        /// Default value as hex string
        /// </summary>
        public static string LastAssetIdDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> LastAssetId
        ///  The last processed asset id - used when assigning a sequential id.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> LastAssetId(string blockhash, CancellationToken token)
        {
            string parameters = AssetRegistryStorage.LastAssetIdParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> AssetRegistryCalls
    /// </summary>
    public sealed class AssetRegistryCalls
    {
        
        /// <summary>
        /// >> register_asset
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method RegisterAsset(InvArch.NetApi.Generated.Model.orml_traits.asset_registry.AssetMetadata metadata, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32> asset_id)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(metadata.Encode());
            byteArray.AddRange(asset_id.Encode());
            return new Method(14, "AssetRegistry", 0, "register_asset", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> update_asset
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method UpdateAsset(Substrate.NetApi.Model.Types.Primitive.U32 asset_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32> decimals, Substrate.NetApi.Model.Types.Base.BaseOpt<InvArch.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT2> name, Substrate.NetApi.Model.Types.Base.BaseOpt<InvArch.NetApi.Generated.Model.bounded_collections.bounded_vec.BoundedVecT2> symbol, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> existential_deposit, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseOpt<InvArch.NetApi.Generated.Model.xcm.EnumVersionedLocation>> location, Substrate.NetApi.Model.Types.Base.BaseOpt<InvArch.NetApi.Generated.Model.invarch_runtime.assets.CustomMetadata> additional)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(asset_id.Encode());
            byteArray.AddRange(decimals.Encode());
            byteArray.AddRange(name.Encode());
            byteArray.AddRange(symbol.Encode());
            byteArray.AddRange(existential_deposit.Encode());
            byteArray.AddRange(location.Encode());
            byteArray.AddRange(additional.Encode());
            return new Method(14, "AssetRegistry", 1, "update_asset", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> AssetRegistryConstants
    /// </summary>
    public sealed class AssetRegistryConstants
    {
        
        /// <summary>
        /// >> StringLimit
        ///  The maximum length of a name or symbol.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 StringLimit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x14000000");
            return result;
        }
    }
    
    /// <summary>
    /// >> AssetRegistryErrors
    /// </summary>
    public enum AssetRegistryErrors
    {
        
        /// <summary>
        /// >> AssetNotFound
        /// Asset was not found.
        /// </summary>
        AssetNotFound,
        
        /// <summary>
        /// >> BadVersion
        /// The version of the `VersionedLocation` value used is not able
        /// to be interpreted.
        /// </summary>
        BadVersion,
        
        /// <summary>
        /// >> InvalidAssetId
        /// The asset id is invalid.
        /// </summary>
        InvalidAssetId,
        
        /// <summary>
        /// >> ConflictingLocation
        /// Another asset was already register with this location.
        /// </summary>
        ConflictingLocation,
        
        /// <summary>
        /// >> ConflictingAssetId
        /// Another asset was already register with this asset id.
        /// </summary>
        ConflictingAssetId,
        
        /// <summary>
        /// >> InvalidAssetString
        /// Name or symbol is too long.
        /// </summary>
        InvalidAssetString,
    }
}
