//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace InvArch.NetApi.Generated.Model.pallet_balances.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains one variant per dispatchable that can be called by an extrinsic.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> transfer_allow_death
        /// Transfer some liquid free balance to another account.
        /// 
        /// `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
        /// If the sender's account is below the existential deposit as a result
        /// of the transfer, the account will be reaped.
        /// 
        /// The dispatch origin for this call must be `Signed` by the transactor.
        /// </summary>
        transfer_allow_death = 0,
        
        /// <summary>
        /// >> set_balance_deprecated
        /// Set the regular balance of a given account; it also takes a reserved balance but this
        /// must be the same as the account's current reserved balance.
        /// 
        /// The dispatch origin for this call is `root`.
        /// 
        /// WARNING: This call is DEPRECATED! Use `force_set_balance` instead.
        /// </summary>
        set_balance_deprecated = 1,
        
        /// <summary>
        /// >> force_transfer
        /// Exactly as `transfer_allow_death`, except the origin must be root and the source account
        /// may be specified.
        /// </summary>
        force_transfer = 2,
        
        /// <summary>
        /// >> transfer_keep_alive
        /// Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
        /// kill the origin account.
        /// 
        /// 99% of the time you want [`transfer_allow_death`] instead.
        /// 
        /// [`transfer_allow_death`]: struct.Pallet.html#method.transfer
        /// </summary>
        transfer_keep_alive = 3,
        
        /// <summary>
        /// >> transfer_all
        /// Transfer the entire transferable balance from the caller account.
        /// 
        /// NOTE: This function only attempts to transfer _transferable_ balances. This means that
        /// any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
        /// transferred by this function. To ensure that this function results in a killed account,
        /// you might need to prepare the account by removing any reference counters, storage
        /// deposits, etc...
        /// 
        /// The dispatch origin of this call must be Signed.
        /// 
        /// - `dest`: The recipient of the transfer.
        /// - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
        ///   of the funds the account has, causing the sender account to be killed (false), or
        ///   transfer everything except at least the existential deposit, which will guarantee to
        ///   keep the sender account alive (true).
        /// </summary>
        transfer_all = 4,
        
        /// <summary>
        /// >> force_unreserve
        /// Unreserve some balance from a user by force.
        /// 
        /// Can only be called by ROOT.
        /// </summary>
        force_unreserve = 5,
        
        /// <summary>
        /// >> upgrade_accounts
        /// Upgrade a specified account.
        /// 
        /// - `origin`: Must be `Signed`.
        /// - `who`: The account to be upgraded.
        /// 
        /// This will waive the transaction fee if at least all but 10% of the accounts needed to
        /// be upgraded. (We let some not have to be upgraded just in order to allow for the
        /// possibililty of churn).
        /// </summary>
        upgrade_accounts = 6,
        
        /// <summary>
        /// >> transfer
        /// Alias for `transfer_allow_death`, provided only for name-wise compatibility.
        /// 
        /// WARNING: DEPRECATED! Will be released in approximately 3 months.
        /// </summary>
        transfer = 7,
        
        /// <summary>
        /// >> force_set_balance
        /// Set the regular balance of a given account.
        /// 
        /// The dispatch origin for this call is `root`.
        /// </summary>
        force_set_balance = 8,
    }
    
    /// <summary>
    /// >> 160 - Variant[pallet_balances.pallet.Call]
    /// Contains one variant per dispatchable that can be called by an extrinsic.
    /// </summary>
    public sealed class EnumCall : BaseEnumRust<Call>
    {
        
        /// <summary>
        /// Initializes a new instance of the class.
        /// </summary>
        public EnumCall()
        {
				AddTypeDecoder<BaseTuple<InvArch.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>>(Call.transfer_allow_death);
				AddTypeDecoder<BaseTuple<InvArch.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>>(Call.set_balance_deprecated);
				AddTypeDecoder<BaseTuple<InvArch.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, InvArch.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>>(Call.force_transfer);
				AddTypeDecoder<BaseTuple<InvArch.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>>(Call.transfer_keep_alive);
				AddTypeDecoder<BaseTuple<InvArch.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Primitive.Bool>>(Call.transfer_all);
				AddTypeDecoder<BaseTuple<InvArch.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Primitive.U128>>(Call.force_unreserve);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Base.BaseVec<InvArch.NetApi.Generated.Model.sp_core.crypto.AccountId32>>(Call.upgrade_accounts);
				AddTypeDecoder<BaseTuple<InvArch.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>>(Call.transfer);
				AddTypeDecoder<BaseTuple<InvArch.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>>(Call.force_set_balance);
        }
    }
}
