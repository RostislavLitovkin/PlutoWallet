//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace InvArch.NetApi.Generated.Model.pallet_contracts.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> call_old_weight
        /// Deprecated version if [`Self::call`] for use in an in-storage `Call`.
        /// </summary>
        call_old_weight = 0,
        
        /// <summary>
        /// >> instantiate_with_code_old_weight
        /// Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`.
        /// </summary>
        instantiate_with_code_old_weight = 1,
        
        /// <summary>
        /// >> instantiate_old_weight
        /// Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`.
        /// </summary>
        instantiate_old_weight = 2,
        
        /// <summary>
        /// >> upload_code
        /// Upload new `code` without instantiating a contract from it.
        /// 
        /// If the code does not already exist a deposit is reserved from the caller
        /// and unreserved only when [`Self::remove_code`] is called. The size of the reserve
        /// depends on the size of the supplied `code`.
        /// 
        /// If the code already exists in storage it will still return `Ok` and upgrades
        /// the in storage version to the current
        /// [`InstructionWeights::version`](InstructionWeights).
        /// 
        /// - `determinism`: If this is set to any other value but [`Determinism::Enforced`] then
        ///   the only way to use this code is to delegate call into it from an offchain execution.
        ///   Set to [`Determinism::Enforced`] if in doubt.
        /// 
        /// # Note
        /// 
        /// Anyone can instantiate a contract from any uploaded code and thus prevent its removal.
        /// To avoid this situation a constructor could employ access control so that it can
        /// only be instantiated by permissioned entities. The same is true when uploading
        /// through [`Self::instantiate_with_code`].
        /// 
        /// Use [`Determinism::Relaxed`] exclusively for non-deterministic code. If the uploaded
        /// code is deterministic, specifying [`Determinism::Relaxed`] will be disregarded and
        /// result in higher gas costs.
        /// </summary>
        upload_code = 3,
        
        /// <summary>
        /// >> remove_code
        /// Remove the code stored under `code_hash` and refund the deposit to its owner.
        /// 
        /// A code can only be removed by its original uploader (its owner) and only if it is
        /// not used by any contract.
        /// </summary>
        remove_code = 4,
        
        /// <summary>
        /// >> set_code
        /// Privileged function that changes the code of an existing contract.
        /// 
        /// This takes care of updating refcounts and all other necessary operations. Returns
        /// an error if either the `code_hash` or `dest` do not exist.
        /// 
        /// # Note
        /// 
        /// This does **not** change the address of the contract in question. This means
        /// that the contract address is no longer derived from its code hash after calling
        /// this dispatchable.
        /// </summary>
        set_code = 5,
        
        /// <summary>
        /// >> call
        /// Makes a call to an account, optionally transferring some balance.
        /// 
        /// # Parameters
        /// 
        /// * `dest`: Address of the contract to call.
        /// * `value`: The balance to transfer from the `origin` to `dest`.
        /// * `gas_limit`: The gas limit enforced when executing the constructor.
        /// * `storage_deposit_limit`: The maximum amount of balance that can be charged from the
        ///   caller to pay for the storage consumed.
        /// * `data`: The input data to pass to the contract.
        /// 
        /// * If the account is a smart-contract account, the associated code will be
        /// executed and any value will be transferred.
        /// * If the account is a regular account, any value will be transferred.
        /// * If no account exists and the call value is not less than `existential_deposit`,
        /// a regular account will be created and any value will be transferred.
        /// </summary>
        call = 6,
        
        /// <summary>
        /// >> instantiate_with_code
        /// Instantiates a new contract from the supplied `code` optionally transferring
        /// some balance.
        /// 
        /// This dispatchable has the same effect as calling [`Self::upload_code`] +
        /// [`Self::instantiate`]. Bundling them together provides efficiency gains. Please
        /// also check the documentation of [`Self::upload_code`].
        /// 
        /// # Parameters
        /// 
        /// * `value`: The balance to transfer from the `origin` to the newly created contract.
        /// * `gas_limit`: The gas limit enforced when executing the constructor.
        /// * `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved
        ///   from the caller to pay for the storage consumed.
        /// * `code`: The contract code to deploy in raw bytes.
        /// * `data`: The input data to pass to the contract constructor.
        /// * `salt`: Used for the address derivation. See [`Pallet::contract_address`].
        /// 
        /// Instantiation is executed as follows:
        /// 
        /// - The supplied `code` is deployed, and a `code_hash` is created for that code.
        /// - If the `code_hash` already exists on the chain the underlying `code` will be shared.
        /// - The destination address is computed based on the sender, code_hash and the salt.
        /// - The smart-contract account is created at the computed address.
        /// - The `value` is transferred to the new account.
        /// - The `deploy` function is executed in the context of the newly-created account.
        /// </summary>
        instantiate_with_code = 7,
        
        /// <summary>
        /// >> instantiate
        /// Instantiates a contract from a previously deployed wasm binary.
        /// 
        /// This function is identical to [`Self::instantiate_with_code`] but without the
        /// code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary
        /// must be supplied.
        /// </summary>
        instantiate = 8,
        
        /// <summary>
        /// >> migrate
        /// When a migration is in progress, this dispatchable can be used to run migration steps.
        /// Calls that contribute to advancing the migration have their fees waived, as it's helpful
        /// for the chain. Note that while the migration is in progress, the pallet will also
        /// leverage the `on_idle` hooks to run migration steps.
        /// </summary>
        migrate = 9,
    }
    
    /// <summary>
    /// >> 302 - Variant[pallet_contracts.pallet.Call]
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public sealed class EnumCall : BaseEnumRust<Call>
    {
        
        /// <summary>
        /// Initializes a new instance of the class.
        /// </summary>
        public EnumCall()
        {
				AddTypeDecoder<BaseTuple<InvArch.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U64>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>>>(Call.call_old_weight);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U64>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>>>(Call.instantiate_with_code_old_weight);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U64>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>, InvArch.NetApi.Generated.Model.primitive_types.H256, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>>>(Call.instantiate_old_weight);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>, InvArch.NetApi.Generated.Model.pallet_contracts.wasm.EnumDeterminism>>(Call.upload_code);
				AddTypeDecoder<InvArch.NetApi.Generated.Model.primitive_types.H256>(Call.remove_code);
				AddTypeDecoder<BaseTuple<InvArch.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, InvArch.NetApi.Generated.Model.primitive_types.H256>>(Call.set_code);
				AddTypeDecoder<BaseTuple<InvArch.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, InvArch.NetApi.Generated.Model.sp_weights.weight_v2.Weight, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>>>(Call.call);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, InvArch.NetApi.Generated.Model.sp_weights.weight_v2.Weight, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>>>(Call.instantiate_with_code);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, InvArch.NetApi.Generated.Model.sp_weights.weight_v2.Weight, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>, InvArch.NetApi.Generated.Model.primitive_types.H256, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>>>(Call.instantiate);
				AddTypeDecoder<InvArch.NetApi.Generated.Model.sp_weights.weight_v2.Weight>(Call.migrate);
        }
    }
}
